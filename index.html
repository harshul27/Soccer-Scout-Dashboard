<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Sports Scout Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Include SheetJS (xlsx) library for Excel file parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- html2canvas for capturing DOM for PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- jsPDF for generating PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Slate & Sky -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .chart-container {
            position: relative;
            margin: auto;
            height: 40vh;
            width: 100%;
            max-height: 400px;
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 45vh;
                max-height: 450px;
            }
        }
        .tooltip {
            background-color: #334155; /* slate-700 */
            color: white;
        }
        .tooltip-title {
            font-weight: 700;
            padding: 8px;
            border-bottom: 1px solid #475569; /* slate-600 */
        }
        .tooltip-body {
            padding: 8px;
        }
        .tooltip-label {
            display: inline-block;
            width: 10px;
            height: 10px;
            margin-right: 5px;
            border-radius: 2px;
        }
        .collapsible-header {
            cursor: pointer;
            user-select: none;
        }
        .collapsible-content {
            transition: max-height 0.3s ease-out;
            overflow: hidden;
        }
        .collapsible-content.hidden {
            max-height: 0;
        }
        iframe {
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); /* shadow-md */
        }
    </style>
</head>
<body class="text-slate-800">

    <div class="container mx-auto p-4 md:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-slate-900">Sports Scout Analytics Dashboard</h1>
            <p class="mt-2 text-lg text-slate-600">Upload player data to generate an interactive performance analysis.</p>
        </header>

        <main id="dashboard-main-content"> <!-- Added ID for PDF export -->
            <!-- New Introduction Section -->
            <section id="introduction-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                <h2 class="text-2xl font-bold text-slate-900 mb-4">Welcome to the Sports Scout Analytics Dashboard!</h2>
                <p class="text-slate-700 mb-4">
                    This interactive tool is designed for soccer scouts, analysts, and enthusiasts to gain deep insights into player performance.
                    By uploading your own datasets, you can visualize key metrics, compare players, analyze trends, project potential,
                    and even generate AI-powered scouting reports. Dive into the data and discover the next big talent or
                    uncover hidden strengths in your favorite players!
                </p>
            </section>

            <!-- New How to Use Section -->
            <section id="how-to-use-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#how-to-use-content">
                    <span>How to Use This Dashboard</span>
                    <span class="transform transition-transform duration-200 rotate-0">▼</span>
                </button>
                <div id="how-to-use-content" class="p-4 collapsible-content hidden">
                    <ol class="list-decimal list-inside text-slate-700 space-y-2">
                        <li>
                            **Upload Player Data:** Click the "Upload Player Data" button and select your CSV or Excel file(s).
                            The dashboard will automatically process the data.
                        </li>
                        <li>
                            **Select a Player:** Once data is loaded, choose a player from the "Select a Player" dropdown to view their detailed analysis.
                        </li>
                        <li>
                            **Filter Peer Group:** Use the "Peer Group Filters" to define the comparison group (e.g., by age or minutes played). Click "Apply Filters" to update.
                        </li>
                        <li>
                            **Customize Charts:** In the "Customize Charts" section, select specific metrics for the Radar and Bar charts. Use the "Reset Metrics" button to revert to default selections.
                        </li>
                        <li>
                            **Explore Visualizations:**
                            <ul class="list-disc list-inside ml-4">
                                <li>**Performance Profile (Radar Chart):** Shows player's percentile rank against their peer group.</li>
                                <li>**Metric Comparison (Bar Chart):** Compares player's raw metric values to the group average.</li>
                                <li>**Scatter Plot:** Visualize any two metrics for all players in the dataset, with the selected player highlighted.</li>
                                <li>**Player Season Trends:** See how a player's key metrics have evolved over different seasons (if historical data is available).</li>
                                <li>**Player Potential Projection:** Get a heuristic-based projection of a player's future performance.</li>
                            </ul>
                        </li>
                        <li>
                            **Player Comparison Mode:** Select up to three players to compare their raw metric values side-by-side in a table.
                        </li>
                        <li>
                            **Detailed Metric Breakdown:** View a comprehensive table of all categorized metrics, including player value, group average, and percentile rank. Adjust conditional formatting thresholds.
                        </li>
                        <li>
                            **AI-Powered Scouting Insight:** Generate a narrative report highlighting strengths and weaknesses using AI.
                        </li>
                        <li>
                            **Export Data:** Download chart images as PNG, detailed metrics as CSV, or the full dashboard report as a PDF.
                        </li>
                    </ol>
                </div>
            </section>

            <!-- Live Score Tab -->
            <section id="live-scores-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#live-scores-content">
                    <span>⚽ Live Soccer Scores</span>
                    <span class="transform transition-transform duration-200 rotate-0">▼</span>
                </button>
                <div id="live-scores-content" class="p-4 collapsible-content hidden">
                    <p class="text-sm text-slate-600 mb-4">Stay updated with live soccer match scores from around the world. Click on a match to go to its details page.</p>
                    <div class="w-full aspect-video md:aspect-auto md:h-96">
                        <!-- Sofascore widget embed -->
                        <iframe 
                            src="https://www.sofascore.com/widget/football" 
                            width="100%" 
                            height="100%" 
                            frameborder="0" 
                            scrolling="no"
                            allowtransparency="true"
                            title="Live Soccer Scores by Sofascore"
                        ></iframe>
                    </div>
                    <p class="text-xs text-slate-500 mt-2">Data provided by <a href="https://www.sofascore.com/" target="_blank" class="text-sky-600 hover:underline">Sofascore</a>.</p>
                </div>
            </section>


            <section id="controls" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                    <div>
                        <label for="file-upload" class="block text-sm font-medium text-slate-700 mb-2">1. Upload Player Data (CSV or Excel)</label>
                        <input id="file-upload" type="file" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-sky-50 file:text-sky-700 hover:file:bg-sky-100 transition-colors duration-200">
                        <p id="file-status" class="text-xs text-slate-500 mt-2">No file selected.</p>
                    </div>
                    <div>
                        <label for="player-select" class="block text-sm font-medium text-slate-700 mb-2">2. Select a Player</label>
                        <select id="player-select" disabled class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500 disabled:bg-slate-100 disabled:cursor-not-allowed transition-all duration-200">
                            <option>Upload a file first</option>
                        </select>
                    </div>
                </div>
                <!-- User-Defined Filters for Peer Group -->
                <div class="mt-6 p-4 bg-slate-50 rounded-lg">
                    <h4 class="text-md font-semibold text-slate-800 mb-3">Peer Group Filters</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <label for="min-age-filter" class="block text-sm font-medium text-slate-700">Min Age</label>
                            <input type="number" id="min-age-filter" min="15" max="45" value="15" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                        </div>
                        <div>
                            <label for="max-age-filter" class="block text-sm font-medium text-slate-700">Max Age</label>
                            <input type="number" id="max-age-filter" min="15" max="45" value="45" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                        </div>
                        <div>
                            <label for="min-minutes-filter" class="block text-sm font-medium text-slate-700">Min Minutes Played</label>
                            <input type="number" id="min-minutes-filter" min="0" value="0" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                        </div>
                    </div>
                    <button id="apply-filters-btn" class="mt-4 bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">Apply Filters</button>
                </div>
            </section>

            <div id="dashboard-content" class="hidden">
                <section id="player-profile-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#player-profile-content">
                        <span>Player Profile</span>
                        <span class="transform transition-transform duration-200 rotate-0">▼</span>
                    </button>
                    <div id="player-profile-content" class="p-4 collapsible-content">
                        <h2 class="text-2xl font-bold text-slate-900 mb-4" id="profile-name">Player Profile</h2>
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                            <div>
                                <p class="text-sm text-slate-500">Position</p>
                                <p class="text-xl font-semibold" id="profile-position">-</p>
                            </div>
                            <div>
                                <p class="text-sm text-slate-500">Team</p>
                                <p class="text-xl font-semibold" id="profile-team">-</p>
                            </div>
                            <div>
                                <p class="text-sm text-slate-500">Nationality</p>
                                <p class="text-xl font-semibold" id="profile-nationality">-</p>
                            </div>
                            <div>
                                <p class="text-sm text-slate-500">Age</p>
                                <p class="text-xl font-semibold" id="profile-age">-</p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Interactive Metric Selection -->
                <section id="customize-charts-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#customize-charts-content">
                        <span>Customize Charts</span>
                        <span class="transform transition-transform duration-200 rotate-0">▼</span>
                    </button>
                    <div id="customize-charts-content" class="p-4 collapsible-content hidden">
                        <h3 class="text-xl font-bold text-slate-900 mb-3">Select Metrics for Radar & Bar Charts</h3>
                        <p class="text-sm text-slate-600 mb-4">Choose up to 8 metrics for the Radar Chart and up to 12 for the Bar Chart.</p>
                        <div id="metric-checkboxes" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2">
                            <!-- Checkboxes will be dynamically loaded here -->
                        </div>
                        <div class="flex flex-wrap gap-4 mt-4">
                            <button id="apply-metric-selection-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">Apply Metric Selection</button>
                            <button id="reset-metrics-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">Reset Metrics</button>
                        </div>
                    </div>
                </section>

                <section class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
                    <div class="bg-white p-6 rounded-xl shadow-md">
                        <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#radar-chart-content">
                            <span>Performance Profile (Radar Chart)</span>
                            <span class="transform transition-transform duration-200 rotate-0">▼</span>
                        </button>
                        <div id="radar-chart-content" class="p-4 collapsible-content">
                            <p class="text-sm text-slate-600 mb-4">Player's percentile rank vs peers in the same position for key metrics (per 90 minutes).</p>
                            <div class="chart-container">
                                <canvas id="radar-chart"></canvas>
                            </div>
                            <button class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full text-sm export-chart-btn" data-chart-id="radar-chart">Export Chart as PNG</button>
                        </div>
                    </div>
                    <div class="bg-white p-6 rounded-xl shadow-md">
                        <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#bar-chart-content">
                            <span>Metric Comparison (Bar Chart)</span>
                            <span class="transform transition-transform duration-200 rotate-0">▼</span>
                        </button>
                        <div id="bar-chart-content" class="p-4 collapsible-content">
                            <p class="text-sm text-slate-600 mb-4">Player's raw metric values (per 90 minutes) compared to the average of their peer group.</p>
                            <div class="chart-container">
                                <canvas id="bar-chart"></canvas>
                            </div>
                            <button class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full text-sm export-chart-btn" data-chart-id="bar-chart">Export Chart as PNG</button>
                        </div>
                    </div>
                </section>

                <!-- New section for Scatter Plot -->
                <section id="scatter-plot-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#scatter-plot-content">
                        <span>Scatter Plot (Player vs. Peer Group)</span>
                        <span class="transform transition-transform duration-200 rotate-0">▼</span>
                    </button>
                    <div id="scatter-plot-content" class="p-4 collapsible-content hidden">
                        <h3 class="text-xl font-bold text-slate-900 mb-3">Compare Two Metrics Across All Players</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                            <div>
                                <label for="scatter-x-metric" class="block text-sm font-medium text-slate-700 mb-1">X-Axis Metric</label>
                                <select id="scatter-x-metric" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                    <option value="">Select Metric</option>
                                </select>
                            </div>
                            <div>
                                <label for="scatter-y-metric" class="block text-sm font-medium text-slate-700 mb-1">Y-Axis Metric</label>
                                <select id="scatter-y-metric" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                    <option value="">Select Metric</option>
                                </select>
                            </div>
                        </div>
                        <button id="update-scatter-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">Update Scatter Plot</button>
                        <div class="chart-container mt-4">
                            <canvas id="scatter-chart"></canvas>
                        </div>
                        <p id="scatter-message" class="text-center text-slate-500 mt-8 hidden"></p>
                        <button class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full text-sm export-chart-btn" data-chart-id="scatter-chart">Export Chart as PNG</button>
                    </div>
                </section>

                <!-- New section for Player Season Trends -->
                <section id="season-trends-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#season-trends-content">
                        <span>Player Season Trends</span>
                        <span class="transform transition-transform duration-200 rotate-0">▼</span>
                    </button>
                    <div id="season-trends-content" class="p-4 collapsible-content hidden">
                        <h3 class="text-xl font-bold text-slate-900 mb-1">Historical Performance Trends (Per 90 Rates)</h3>
                        <p class="text-sm text-slate-600 mb-4">View how selected key metrics have evolved over all available seasons for the player.</p>
                        <div class="chart-container">
                            <canvas id="season-trends-chart"></canvas>
                        </div>
                        <p id="season-trends-message" class="text-center text-slate-500 mt-8 hidden"></p>
                        <button class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full text-sm export-chart-btn" data-chart-id="season-trends-chart">Export Chart as PNG</button>
                    </div>
                </section>

                <!-- Player Potential Projection -->
                <section id="projection-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#projection-content">
                        <span>Player Potential Projection (Per 90 Rates)</span>
                        <span class="transform transition-transform duration-200 rotate-0">▼</span>
                    </button>
                    <div id="projection-content" class="p-4 collapsible-content hidden">
                        <p class="text-sm text-slate-600 mb-4">Projected per 90 rates over hypothetical future seasons based on age and current performance. (Heuristic-based)</p>
                        <div class="chart-container" id="projection-chart-container">
                            <canvas id="projection-chart"></canvas>
                            <p id="projection-message" class="text-center text-slate-500 mt-8 hidden"></p>
                        </div>
                        <button class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full text-sm export-chart-btn" data-chart-id="projection-chart">Export Chart as PNG</button>
                    </div>
                </section>

                <!-- Player Comparison Mode -->
                <section id="player-comparison-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#player-comparison-content">
                        <span>Player Comparison Mode</span>
                        <span class="transform transition-transform duration-200 rotate-0">▼</span>
                    </button>
                    <div id="player-comparison-content" class="p-4 collapsible-content hidden">
                        <h3 class="text-xl font-bold text-slate-900 mb-3">Compare Players Side-by-Side</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                            <div>
                                <label for="compare-player-1" class="block text-sm font-medium text-slate-700 mb-1">Player 1</label>
                                <select id="compare-player-1" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                    <option value="">Select Player</option>
                                </select>
                            </div>
                            <div>
                                <label for="compare-player-2" class="block text-sm font-medium text-slate-700 mb-1">Player 2</label>
                                <select id="compare-player-2" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                    <option value="">Select Player</option>
                                </select>
                            </div>
                            <div>
                                <label for="compare-player-3" class="block text-sm font-medium text-slate-700 mb-1">Player 3</label>
                                <select id="compare-player-3" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                    <option value="">Select Player</option>
                                </select>
                            </div>
                        </div>
                        <button id="compare-players-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">Compare Selected Players</button>
                        <div id="comparison-table-container" class="mt-6 hidden">
                            <div class="overflow-x-auto">
                                <table id="comparison-table" class="min-w-full divide-y divide-slate-200">
                                    <!-- Comparison table content will be dynamically loaded here -->
                                </table>
                                <p id="comparison-message" class="text-center text-slate-500 mt-4 hidden"></p>
                            </div>
                        </div>
                    </div>
                </section>

                <section id="detailed-metrics-section" class="bg-white p-6 rounded-xl shadow-md mb-8">
                    <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#detailed-metrics-content">
                        <span>Detailed Metric Breakdown</span>
                        <span class="transform transition-transform duration-200 rotate-0">▼</span>
                    </button>
                    <div id="detailed-metrics-content" class="p-4 collapsible-content">
                        <p class="text-sm text-slate-600 mb-4">Categorized metrics showing player's value, group average, and percentile rank.</p>
                        <!-- Conditional Formatting Customization -->
                        <div class="mb-4 p-3 bg-slate-100 rounded-lg">
                            <h4 class="text-md font-semibold text-slate-800 mb-2">Conditional Formatting Thresholds</h4>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div>
                                    <label for="good-threshold" class="block text-sm font-medium text-slate-700">Good Performance (Percentile >=)</label>
                                    <input type="number" id="good-threshold" min="50" max="100" value="75" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                </div>
                                <div>
                                    <label for="poor-threshold" class="block text-sm font-medium text-slate-700">Poor Performance (Percentile <=)</label>
                                    <input type="number" id="poor-threshold" min="0" max="50" value="25" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                </div>
                            </div>
                            <button id="apply-formatting-btn" class="mt-4 bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">Apply Formatting</button>
                        </div>

                        <div id="categorized-metrics-table-container">
                            <!-- Categories will be dynamically inserted here -->
                        </div>
                        <button id="export-detailed-csv-btn" class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full text-sm">Export Detailed Metrics as CSV</button>
                    </div>
                </section>

                <section id="ai-insight-section" class="bg-white p-6 rounded-xl shadow-md">
                    <button class="w-full text-left p-2 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center rounded-md collapsible-header" data-target="#ai-insight-content">
                        <span>✨ AI-Powered Scouting Insight</span>
                        <span class="transform transition-transform duration-200 rotate-0">▼</span>
                    </button>
                    <div id="ai-insight-content" class="p-4 collapsible-content">
                        <p class="text-sm text-slate-600 mb-4">Generate a narrative scouting report highlighting strengths and weaknesses based on the current player's data.</p>
                        <button id="generate-insight-btn" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Generate Insight
                        </button>
                        <div id="insight-output" class="mt-4 p-4 bg-slate-50 rounded-lg text-slate-700 hidden">
                            <p id="insight-text" class="whitespace-pre-wrap"></p>
                            <p id="insight-loading" class="text-center text-sky-600 hidden">Generating insight...</p>
                        </div>
                    </div>
                </section>

                <section id="report-export-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mt-8">
                    <h3 class="text-xl font-bold text-slate-900 mb-3">Export Full Report</h3>
                    <p class="text-sm text-slate-600 mb-4">Download a PDF version of the entire dashboard content for offline viewing or sharing.</p>
                    <button id="download-pdf-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">
                        Download Full Report as PDF
                    </button>
                </section>

            </div>
             <div id="initial-message" class="text-center py-12">
                <p class="text-slate-500">Your interactive dashboard will appear here once you upload data.</p>
            </div>
        </main>
    </div>

    <script>
        let playerData = []; // This will store the fully cleaned, preprocessed, and combined data
        let radarChart = null;
        let barChart = null;
        let projectionChart = null; // New chart instance for projections
        let seasonTrendsChart = null; // New chart instance for season trends
        let scatterChart = null; // New chart instance for scatter plot
        let currentAnalytics = {}; // Store current analytics for LLM prompt
        let allAvailableMetrics = []; // To store all numeric metrics for selection
        let selectedRadarMetrics = new Set();
        let selectedBarMetrics = new Set();
        
        // Default thresholds for conditional formatting
        let goodPerformanceThreshold = 75; // Percentile >= 75%
        let poorPerformanceThreshold = 25;  // Percentile <= 25%

        // Define keywords for metric categorization (case-insensitive) - EXPANDED
        const METRIC_KEYWORDS = {
            'offensive': [
                'goal', 'goals', 'shot', 'shots', 'assist', 'assists', 'conversion', 'xg', 'xa', 'dribble', 'dribbles', 'touches',
                'big chances missed', 'hit woodwork', 'offsides', 'carries ended with goal', 'carries ended with assist', 
                'carries ended with shot', 'carries ended with chance', 'progressive carries', 'through balls', 'crosses', 
                'successful crosses', 'fthird passes', 'successful fthird passes', 'key passes', 'chances created'
            ],
            'defensive': [
                'tackle', 'tackles', 'interception', 'interceptions', 'block', 'blocks', 'clearance', 'clearances', 
                'possession won', 'dispossessed', 'ground duels', 'gduels won', 'aerial duels', 'aduels won', 'pressure', 'pressures'
            ],
            'passing': [
                'pass', 'passes', 'successful passes', 'passes%', 'accuracy', 'through ball', 'carries', 'touches',
                'crosses', 'successful crosses', 'crosses %', 'fthird passes', 'successful fthird passes', 'fthird passes %',
                'long passes', 'short passes'
            ],
            'goalkeeping': [
                'save', 'saves', 'saves %', 'penalties saved', 'high claims', 'punches', 'goals conceded', 'xgot conceded', 
                'goals prevented', 'clearances off line', 'crosses stopped'
            ],
            'physical': [ // Explicitly added for clarity
                'minutes', 'appearances', 'sprints', 'distance covered', 'high intensity runs', 'acceleration', 'deceleration',
                'recoveries', 'duels', 'won', 'lost', 'aerial', 'ground'
            ],
            'mental': [ // Renamed from general for more specific metrics
                'fouls', 'yellow cards', 'red cards', 'own goals', 'leadership', 'composure', 'decision making', 'errors'
            ],
            'financial': [ // New category if data is present
                'market value', 'salary', 'contract'
            ]
        };

        // Map general position terms to more standardized ones if needed
        const POSITION_ALIASES = {
            'forward': 'Forward', 'striker': 'Forward', 'st': 'Forward', 'cf': 'Forward', 'lw': 'Forward', 'rw': 'Forward',
            'midfielder': 'Midfielder', 'mid': 'Midfielder', 'cm': 'Midfielder', 'cdm': 'Midfielder', 'cam': 'Midfielder',
            'def': 'DEF', 'defender': 'DEF', 'cb': 'DEF', 'lb': 'DEF', 'rb': 'DEF', 'lcb': 'DEF', 'rcb': 'DEF', 'lwb': 'DEF', 'rwb': 'DEF',
            'gkp': 'GKP', 'goalkeeper': 'GKP', 'gk': 'GKP'
        };

        // Map positions to relevant metric categories (ordered by importance for radar chart selection)
        const POSITION_TO_CATEGORIES = {
            'Forward': ['offensive', 'passing', 'physical', 'mental'],
            'Midfielder': ['passing', 'defensive', 'offensive', 'physical', 'mental'],
            'DEF': ['defensive', 'passing', 'physical', 'mental'],
            'GKP': ['goalkeeping', 'physical', 'mental'],
            'Unknown': ['offensive', 'defensive', 'passing', 'physical', 'mental'] // Fallback for unknown positions
        };

        // Metrics where lower values are better (for percentile calculation inversion) - EXPANDED
        const LOWER_IS_BETTER_METRICS = [
            'Goals_Conceded_Per_90', 'Fouls_Per_90', 'Yellow_Cards', 'Red_Cards', 'Own_Goals', 'Dispossessed_Per_90', 
            'Big_Chances_Missed_Per_90', 'Errors_Per_90' // Added common error metrics
        ];

        // Metrics to prioritize for per 90 normalization (raw names from CSV or derived names) - EXPANDED
        const BASE_METRICS_FOR_90_CONVERSION = [
            'Goals', 'Assists', 'Shots', 'Shots_On_Target', 'Tackles', 'Interceptions', 'Clearances', 'Saves',
            'Fouls', 'Yellow_Cards', 'Red_Cards', 'Own_Goals', 'Big_Chances_Missed', 'Hit_Woodwork', 'Offsides',
            'Touches', 'Passes', 'Successful_Passes', 'Crosses', 'Successful_Crosses', 'fThird_Passes', 'Successful_fThird_Passes',
            'Carries', 'Progressive_Carries', 'Carries_Ended_with_Goal', 'Carries_Ended_with_Assist', 'Carries_Ended_with_Shot',
            'Carries_Ended_with_Chance', 'Possession_Won', 'Dispossessed', 'Ground_Duels', 'gDuels_Won', 'Aerial_Duels', 'aDuels_Won',
            'Goals_Conceded', 'xGoT_Conceded', 'Goals_Prevented', 'Clearances_Off_Line', 'Punches', 'High_Claims', 'Penalties_Saved',
            'Sprints', 'Distance_Covered', 'High_Intensity_Runs', 'Fouls_Won', 'Key_Passes', 'Chances_Created',
            'Dribbles', 'Successful_Dribbles', 'Pressures', 'Successful_Pressures', 'Errors', 'Long_Passes', 'Short_Passes',
            'xA', 'xG', 'Crosses_Stopped'
        ];

        // Comprehensive metric categorization for the detailed table - EXPANDED
        const DETAILED_METRIC_CATEGORIES = {
            'Physical': [
                'Minutes_Played', 'Appearances', 'Sprints_Per_90', 'Distance_Covered_Per_90', 'High_Intensity_Runs_Per_90',
                'Ground_Duels_Per_90', 'gDuels_Won_Per_90', 'Aerial_Duels_Per_90', 'aDuels_Won_Per_90',
                'Carries_Per_90', 'Progressive_Carries_Per_90', 'Dispossessed_Per_90'
            ],
            'Technical': [
                'Goals_Per_90', 'Assists_Per_90', 'Shots_Per_90', 'Shots_On_Target_Per_90', 'Conversion_Pct', 'xG_Per_90', 'xA_Per_90',
                'Passing_Accuracy_Pct', 'Successful_Passes_Per_90', 'Long_Passes_Per_90', 'Short_Passes_Per_90', 'Through_Balls_Per_90',
                'Crosses_Per_90', 'Successful_Crosses_Per_90', 'Touches_Per_90', 'Dribbles_Per_90', 'Successful_Dribbles_Per_90',
                'Saves_Per_90', 'Saves_Pct', 'Penalties_Saved', 'Clean_Sheets', 'Goals_Prevented', 'Clearances_Off_Line', 'Punches', 'High_Claims',
                'Crosses_Stopped_Per_90'
            ],
            'Tactical': [
                'Interceptions_Per_90', 'Tackles_Per_90', 'Blocks_Per_90', 'Clearances_Per_90', 'Possession_Won_Per_90',
                'Fouls_Won_Per_90', 'Offsides_Per_90', 'Key_Passes_Per_90', 'Chances_Created_Per_90',
                'fThird_Passes_Per_90', 'Successful_fThird_Passes_Per_90', 'xGoT_Conceded_Per_90',
                'Pressures_Per_90', 'Successful_Pressures_Per_90'
            ],
            'Mental_Discipline': [ 
                'Fouls_Per_90', 'Yellow_Cards', 'Red_Cards', 'Big_Chances_Missed_Per_90', 'Own_Goals', 'Leadership_Rating',
                'Errors_Per_90'
            ],
            'General': [] // Fallback for metrics not fitting other categories
        };

        // Helper to find a column name from a list of aliases (case-insensitive)
        function findColumn(row, aliases) {
            for (const alias of aliases) {
                const foundKey = Object.keys(row).find(key => key.toLowerCase() === alias.toLowerCase());
                if (foundKey) {
                    return row[foundKey];
                }
            }
            return undefined;
        }

        // Custom CSV parsing function - more robust for quoted fields
        function parseCsvManually(csvText) {
            const lines = csvText.trim().split(/\r?\n/); 
            if (lines.length === 0) return [];

            const headers = [];
            const csvSplitRegex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/; // Regex to split by comma, but not if inside double quotes

            lines[0].split(csvSplitRegex).forEach(h => headers.push(h.trim().replace(/^"|"$/g, ''))); 

            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue; 

                const values = line.split(csvSplitRegex).map(v => v.trim().replace(/^"|"$/g, '')); 

                if (values.length !== headers.length) {
                    console.warn(`Skipping malformed row ${i + 1} due to column count mismatch: ${line}`);
                    continue;
                }
                const rowObject = {};
                headers.forEach((header, index) => {
                    rowObject[header] = values[index];
                });
                data.push(rowObject);
            }
            return data;
        }

        // Enhanced cleanAndPreprocessData for dynamic column handling, deduplication, and derived metrics
        function cleanAndPreprocessData(data) {
            console.log("Starting cleanAndPreprocessData. Raw data rows:", data.length);
            const processedDataMap = new Map(); // Map to store unique player-season combinations

            data.forEach((row, rowIndex) => {
                const newRow = {};
                // Standardize core player info with flexible checks
                newRow.Player_Name = findColumn(row, ['Player Name', 'Player', 'Name']) || 'N/A';
                
                // Try to find a Season/Year column
                let season = findColumn(row, ['Season', 'Year', 'Ssn']);
                if (season) {
                    season = parseInt(season);
                    if (isNaN(season)) season = 'N/A'; // Ensure it's a number or N/A
                } else {
                    season = 'N/A'; // Indicate missing season data if no column found
                }
                newRow.Season = season;

                // Create a unique ID for player + season for deduplication
                // If Season is 'N/A', treat all records for a player as one "season" for deduplication
                newRow.Player_ID = `${newRow.Player_Name}_${newRow.Season}`; 

                // If this player-season combination already exists, skip (deduplicate)
                if (processedDataMap.has(newRow.Player_ID)) {
                    console.warn(`Skipping duplicate player-season entry for: ${newRow.Player_ID} at row ${rowIndex + 1}`);
                    return; 
                }

                const rawPosition = findColumn(row, ['Position', 'Pos']);
                newRow.Position = rawPosition ? (POSITION_ALIASES[rawPosition.toLowerCase()] || 'N/A') : 'N/A';

                newRow.Team = findColumn(row, ['Club', 'Team']) || 'N/A';
                newRow.Nationality = findColumn(row, ['Nationality']) || 'N/A';
                
                const rawAge = findColumn(row, ['Age']);
                newRow.Age = parseFloat(rawAge); 
                if (isNaN(newRow.Age)) newRow.Age = 'N/A';

                const rawMinutes = findColumn(row, ['Minutes', 'Min', 'MP']);
                newRow.Minutes_Played = parseFloat(rawMinutes);
                if (isNaN(newRow.Minutes_Played)) newRow.Minutes_Played = 0; // Ensure minutes is always a number for calculations
                
                // Process all other columns, attempting to convert to number
                for (const key in row) {
                    const cleanedKey = key.replace(/[^a-zA-Z0-9_]/g, '_').replace(/_{2,}/g, '_').replace(/_$/, ''); // Clean up header names
                    // Only add if not already a core field and not an empty string
                    if (!(cleanedKey in newRow) && row[key] !== '') { 
                        const value = parseFloat(row[key]);
                        newRow[cleanedKey] = isNaN(value) ? row[key] : value; // Keep original if not a number, else store number
                    }
                }

                // Calculate derived metrics and per 90 metrics
                const minutes = newRow.Minutes_Played;

                BASE_METRICS_FOR_90_CONVERSION.forEach(metricKey => {
                    let rawValue = newRow[metricKey];
                    // Handle common aliases for raw metrics in the input CSV/Excel
                    const aliasesMap = {
                        'Goals': ['Gls'], 'Assists': ['Ast'], 'Shots_On_Target': ['SoT'], 'Goals_Conceded': ['GC'],
                        'Yellow_Cards': ['Yellow Cards'], 'Red_Cards': ['Red Cards'], 'Own_Goals': ['Own Goals'],
                        'Big_Chances_Missed': ['Big Chances Missed'], 'Hit_Woodwork': ['Hit Woodwork'], 'Offsides': ['Offsides'],
                        'Touches': ['Touches'], 'Passes': ['Passes'], 'Successful_Passes': ['Successful Passes'],
                        'Crosses': ['Crosses'], 'Successful_Crosses': ['Successful Crosses'],
                        'fThird_Passes': ['fThird Passes'], 'Successful_fThird_Passes': ['Successful fThird Passes'],
                        'Carries': ['Carries'], 'Progressive_Carries': ['Progressive Carries'],
                        'Carries_Ended_with_Goal': ['Carries Ended with Goal'], 'Carries_Ended_with_Assist': ['Carries Ended with Assist'],
                        'Carries_Ended_with_Shot': ['Carries Ended with Shot'], 'Carries_Ended_with_Chance': ['Carries Ended with Chance'],
                        'Possession_Won': ['Possession Won'], 'Dispossessed': ['Dispossessed'],
                        'Ground_Duels': ['Ground Duels'], 'gDuels_Won': ['gDuels Won'],
                        'Aerial_Duels': ['Aerial Duels'], 'aDuels_Won': ['aDuels Won'], 'Fouls': ['Fouls'],
                        'xGoT_Conceded': ['xGoT Conceded'], 'Goals_Prevented': ['Goals Prevented'], 'Clearances_Off_Line': ['Clearances Off Line'],
                        'Punches': ['Punches'], 'High_Claims': ['High Claims'], 'Penalties_Saved': ['Penalties Saved'],
                        'Sprints': ['Sprints'], 'Distance_Covered': ['Distance Covered'], 'High_Intensity_Runs': ['High Intensity Runs'],
                        'Fouls_Won': ['Fouls Won'], 'Key_Passes': ['Key Passes'], 'Chances_Created': ['Chances Created'],
                        'Dribbles': ['Dribbles'], 'Successful_Dribbles': ['Successful Dribbles'], 'Pressures': ['Pressures'],
                        'Successful_Pressures': ['Successful Pressures'], 'Errors': ['Errors'], 'Long_Passes': ['Long Passes'],
                        'Short_Passes': ['Short Passes'], 'xA': ['xA'], 'xG': ['xG'], 'Crosses_Stopped': ['Crosses Stopped']
                    };

                    if (rawValue === undefined && aliasesMap[metricKey]) {
                        for (const alias of aliasesMap[metricKey]) {
                            const foundAliasKey = Object.keys(newRow).find(key => key.toLowerCase() === alias.toLowerCase());
                            if (foundAliasKey) {
                                rawValue = newRow[foundAliasKey]; // Use newRow as it has cleaned keys
                                break;
                            }
                        }
                    }

                    if (typeof rawValue === 'number' && minutes > 0) {
                        newRow[`${metricKey}_Per_90`] = (rawValue / minutes) * 90;
                    } else {
                        newRow[`${metricKey}_Per_90`] = 0;
                    }
                });

                // Specific percentage calculations if raw components exist
                if (typeof newRow.Shots === 'number' && newRow.Shots > 0 && typeof newRow.Shots_On_Target === 'number') {
                    newRow.Shots_on_Target_Pct = (newRow.Shots_On_Target / newRow.Shots) * 100;
                } else {
                    newRow.Shots_on_Target_Pct = 0;
                }
                
                if (typeof newRow.Saves === 'number' && newRow.Saves > 0 && typeof newRow.Goals_Conceded === 'number') {
                    newRow.Saves_Pct = (newRow.Saves / (newRow.Saves + newRow.Goals_Conceded)) * 100;
                } else if (newRow['Saves_Pct'] !== undefined) { 
                    newRow.Saves_Pct = parseFloat(newRow['Saves_Pct']) || 0;
                } else {
                    newRow.Saves_Pct = 0;
                }

                // Handle Passing Accuracy %
                if (newRow['Passes%'] !== undefined) {
                    newRow.Passing_Accuracy_Pct = parseFloat(newRow['Passes%']) || 0;
                } else if (typeof newRow.Successful_Passes === 'number' && typeof newRow.Passes === 'number' && newRow.Passes > 0) {
                    newRow.Passing_Accuracy_Pct = (newRow.Successful_Passes / newRow.Passes) * 100;
                } else {
                    newRow.Passing_Accuracy_Pct = 0;
                }

                processedDataMap.set(newRow.Player_ID, newRow);
            });
            console.log("Processed data map size:", processedDataMap.size);
            return Array.from(processedDataMap.values()); // Return array of unique player-season objects
        }

        function populatePlayerSelect(data) {
            const playerSelect = document.getElementById('player-select');
            playerSelect.innerHTML = '';
            playerSelect.disabled = false;

            if (data.length === 0) {
                const option = document.createElement('option');
                option.textContent = 'No players found in file';
                playerSelect.appendChild(option);
                playerSelect.disabled = true;
                return;
            }
            
            // Get unique player names for the dropdown
            const uniquePlayers = new Map(); // Map to store the latest season's data for each player name
            data.forEach(player => {
                if (!uniquePlayers.has(player.Player_Name) || 
                    (typeof player.Season === 'number' && typeof uniquePlayers.get(player.Player_Name).Season === 'number' && player.Season > uniquePlayers.get(player.Player_Name).Season) ||
                    (uniquePlayers.get(player.Player_Name).Season === 'N/A' && typeof player.Season === 'number') // Prioritize any data with a season over N/A
                    ) {
                    uniquePlayers.set(player.Player_Name, player);
                }
            });

            const sortedPlayers = Array.from(uniquePlayers.values()).sort((a, b) => {
                const nameA = a.Player_Name ? a.Player_Name.toUpperCase() : '';
                const nameB = b.Player_Name ? b.Player_Name.toUpperCase() : '';
                if (nameA < nameB) return -1;
                if (nameA > nameB) return 1;
                return 0;
            });

            sortedPlayers.forEach(player => {
                const option = document.createElement('option');
                // Use the unique Player_Name for the option value, not Player_ID, so all seasons of a player can be selected
                option.value = player.Player_Name; 
                option.textContent = `${player.Player_Name} (${player.Team}${player.Season !== 'N/A' ? `, ${player.Season}` : ''})`;
                playerSelect.appendChild(option);
            });
        }

        function populateComparisonSelects(data) {
            const compareSelect1 = document.getElementById('compare-player-1');
            const compareSelect2 = document.getElementById('compare-player-2');
            const compareSelect3 = document.getElementById('compare-player-3');

            [compareSelect1, compareSelect2, compareSelect3].forEach(select => {
                if (select) { // Defensive check to ensure element exists
                    select.innerHTML = '<option value="">Select Player</option>'; // Reset options
                    const uniquePlayers = new Map();
                    data.forEach(player => {
                        if (!uniquePlayers.has(player.Player_Name)) {
                            uniquePlayers.set(player.Player_Name, player);
                        }
                    });
                    const sortedPlayers = Array.from(uniquePlayers.values()).sort((a, b) => a.Player_Name.localeCompare(b.Player_Name));
                    sortedPlayers.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.Player_Name;
                        option.textContent = `${player.Player_Name} (${player.Team})`;
                        select.appendChild(option);
                    });
                }
            });
        }

        function populateScatterMetricSelects(data) {
            const scatterXMetricSelect = document.getElementById('scatter-x-metric');
            const scatterYMetricSelect = document.getElementById('scatter-y-metric');

            // Clear existing options
            scatterXMetricSelect.innerHTML = '<option value="">Select Metric</option>';
            scatterYMetricSelect.innerHTML = '<option value="">Select Metric</option>';

            const numericMetrics = allAvailableMetrics.filter(metric => 
                data.some(p => typeof p[metric] === 'number' && !isNaN(p[metric]))
            ).sort(); // Sort alphabetically

            numericMetrics.forEach(metric => {
                const optionX = document.createElement('option');
                optionX.value = metric;
                optionX.textContent = metric.replace(/_/g, ' ');
                scatterXMetricSelect.appendChild(optionX);

                const optionY = document.createElement('option');
                optionY.value = metric;
                optionY.textContent = metric.replace(/_/g, ' ');
                scatterYMetricSelect.appendChild(optionY);
            });

            // Set default selections if available (e.g., Goals_Per_90, Assists_Per_90)
            if (numericMetrics.includes('Goals_Per_90')) {
                scatterXMetricSelect.value = 'Goals_Per_90';
            } else if (numericMetrics.length > 0) {
                scatterXMetricSelect.value = numericMetrics[0];
            }

            if (numericMetrics.includes('Assists_Per_90')) {
                scatterYMetricSelect.value = 'Assists_Per_90';
            } else if (numericMetrics.length > 1) {
                scatterYMetricSelect.value = numericMetrics[1];
            }
        }


        function populateMetricCheckboxes(data) {
            const metricCheckboxesDiv = document.getElementById('metric-checkboxes');
            metricCheckboxesDiv.innerHTML = ''; // Clear previous checkboxes

            // Get the currently selected player to determine their position for default metric selection
            const selectedPlayerName = document.getElementById('player-select').value;
            const selectedPlayer = playerData.find(p => p.Player_Name === selectedPlayerName) || playerData[0]; // Fallback to first player

            // Get relevant metrics for the selected player's position
            const { radar: defaultRadarMetrics, bar: defaultBarMetrics } = getRelevantMetricsForPlayer(selectedPlayer, data);

            // If selectedRadarMetrics/selectedBarMetrics are empty (e.g., after reset), then set them to defaults
            if (selectedRadarMetrics.size === 0) {
                selectedRadarMetrics = new Set(defaultRadarMetrics);
            }
            if (selectedBarMetrics.size === 0) {
                selectedBarMetrics = new Set(defaultBarMetrics);
            }

            // Get all unique numeric metrics that have non-zero values across the dataset
            allAvailableMetrics = [];
            const allHeaders = new Set();
            data.forEach(row => Object.keys(row).forEach(key => allHeaders.add(key)));

            allHeaders.forEach(header => {
                const hasMeaningfulNumericData = data.some(row => 
                    typeof row[header] === 'number' && !isNaN(row[header]) && row[header] !== 0
                );
                if (hasMeaningfulNumericData) {
                    allAvailableMetrics.push(header);
                }
            });

            // Prioritize Per_90 metrics for selection
            allAvailableMetrics.sort((a, b) => {
                const aIsPer90 = a.endsWith('_Per_90');
                const bIsPer90 = b.endsWith('_Per_90');
                if (aIsPer90 && !bIsPer90) return -1;
                if (!aIsPer90 && bIsPer90) return 1;
                return a.localeCompare(b); // Alphabetical sort otherwise
            });

            // Populate checkboxes
            allAvailableMetrics.forEach(metric => {
                const div = document.createElement('div');
                div.classList.add('flex', 'items-center');

                const inputRadar = document.createElement('input');
                inputRadar.type = 'checkbox';
                inputRadar.id = `radar-${metric}`;
                inputRadar.name = 'radar-metric';
                inputRadar.value = metric;
                inputRadar.classList.add('form-checkbox', 'h-4', 'w-4', 'text-sky-600', 'rounded', 'focus:ring-sky-500');
                
                if (selectedRadarMetrics.has(metric)) {
                    inputRadar.checked = true;
                }

                const labelRadar = document.createElement('label');
                labelRadar.htmlFor = `radar-${metric}`;
                labelRadar.classList.add('ml-2', 'text-sm', 'text-slate-700');
                labelRadar.textContent = `${metric.replace(/_/g, ' ')} (Radar)`;

                div.appendChild(inputRadar);
                div.appendChild(labelRadar);
                metricCheckboxesDiv.appendChild(div);

                // Add a separate checkbox for bar chart selection (can be different from radar)
                const divBar = document.createElement('div');
                divBar.classList.add('flex', 'items-center');

                const inputBar = document.createElement('input');
                inputBar.type = 'checkbox';
                inputBar.id = `bar-${metric}`;
                inputBar.name = 'bar-metric';
                inputBar.value = metric;
                inputBar.classList.add('form-checkbox', 'h-4', 'w-4', 'text-sky-600', 'rounded', 'focus:ring-sky-500');

                if (selectedBarMetrics.has(metric)) {
                    inputBar.checked = true;
                }

                const labelBar = document.createElement('label');
                labelBar.htmlFor = `bar-${metric}`;
                labelBar.classList.add('ml-2', 'text-sm', 'text-slate-700');
                labelBar.textContent = `${metric.replace(/_/g, ' ')} (Bar)`;

                divBar.appendChild(inputBar);
                divBar.appendChild(labelBar);
                metricCheckboxesDiv.appendChild(divBar);
            });
        }

        function updateDashboard(selectedPlayerName) { // Now takes Player_Name
            // Find the latest season's data for the selected player for profile and current stats
            const selectedPlayer = playerData
                .filter(p => p.Player_Name === selectedPlayerName)
                .sort((a, b) => (typeof b.Season === 'number' ? b.Season : -Infinity) - (typeof a.Season === 'number' ? a.Season : -Infinity))
                [0]; // Get the most recent season's data

            if (!selectedPlayer) return;

            updateProfile(selectedPlayer);
            const { radar: radarMetrics, bar: barMetrics, table: tableMetrics, projection: projectionMetrics, seasonTrends: seasonTrendsMetrics } = getRelevantMetricsForPlayer(selectedPlayer, playerData);
            
            // Calculate analytics for each set of metrics
            const radarAnalytics = calculateAnalytics(selectedPlayer.Player_ID, radarMetrics); // Use Player_ID for analytics to ensure correct peer group
            const barAnalytics = calculateAnalytics(selectedPlayer.Player_ID, barMetrics);
            
            // Calculate analytics for ALL relevant metrics to determine strengths/weaknesses
            const allRelevantMetricsForAnalytics = new Set();
            for (const category in DETAILED_METRIC_CATEGORIES) {
                DETAILED_METRIC_CATEGORIES[category].forEach(metric => {
                    if (typeof selectedPlayer[metric] === 'number' && !isNaN(selectedPlayer[metric])) {
                        allRelevantMetricsForAnalytics.add(metric);
                    }
                });
            }
            currentAnalytics = calculateAnalytics(selectedPlayer.Player_ID, Array.from(allRelevantMetricsForAnalytics)); // Full analytics for AI and table

            createOrUpdateRadarChart(radarAnalytics, selectedPlayer.Player_Name);
            createOrUpdateBarChart(barAnalytics, selectedPlayer.Player_Name);
            createOrUpdateProjectionChart(selectedPlayer, projectionMetrics); // Pass selectedPlayer (latest season) for age and projection metrics
            createOrUpdateSeasonTrendsChart(selectedPlayer, seasonTrendsMetrics); // New: Season Trends Chart
            updateMetricsTable(currentAnalytics, selectedPlayer.Player_Name); // Table uses all relevant metrics
            
            document.getElementById('insight-output').classList.add('hidden'); // Hide previous insight
            document.getElementById('insight-text').textContent = '';

            // Update scatter plot if metrics are selected
            const scatterXMetric = document.getElementById('scatter-x-metric').value;
            const scatterYMetric = document.getElementById('scatter-y-metric').value;
            if (scatterXMetric && scatterYMetric) {
                createOrUpdateScatterPlot(selectedPlayer.Player_ID, scatterXMetric, scatterYMetric);
            } else {
                // If no metrics selected for scatter, destroy chart and show message
                if (scatterChart) {
                    scatterChart.destroy();
                    scatterChart = null;
                }
                document.getElementById('scatter-message').textContent = 'Select X and Y metrics to view the scatter plot.';
                document.getElementById('scatter-message').classList.remove('hidden');
            }
        }

        function updateProfile(player) {
            document.getElementById('profile-name').textContent = player.Player_Name || 'N/A';
            document.getElementById('profile-position').textContent = player.Position || 'N/A';
            document.getElementById('profile-team').textContent = player.Team || 'N/A';
            document.getElementById('profile-nationality').textContent = player.Nationality || 'N/A';
            document.getElementById('profile-age').textContent = player.Age || 'N/A';
        }

        // Identifies all numeric metrics present in the data and categorizes them
        function identifyAndCategorizeMetrics(data) {
            if (data.length === 0) return {};

            // Initialize categories, including 'General'
            const categories = {
                'Physical': [], 'Technical': [], 'Tactical': [], 'Mental_Discipline': [], 'General': []
            };

            // Get all unique headers from all data rows
            let allHeaders = new Set();
            data.forEach(row => {
                Object.keys(row).forEach(key => allHeaders.add(key));
            });
            allHeaders = Array.from(allHeaders);

            allHeaders.forEach(header => {
                // Check if the header represents a numeric metric AND has non-zero values across players
                const hasMeaningfulNumericData = data.some(row => 
                    typeof row[header] === 'number' && !isNaN(row[header]) && row[header] !== 0
                );
                if (hasMeaningfulNumericData) {
                    let assigned = false;
                    // Check against predefined DETAILED_METRIC_CATEGORIES first
                    for (const categoryName in DETAILED_METRIC_CATEGORIES) {
                        if (DETAILED_METRIC_CATEGORIES[categoryName].includes(header)) {
                            categories[categoryName].push(header);
                            assigned = true;
                            break;
                        }
                    }

                    // If not assigned by DETAILED_METRIC_CATEGORIES, try METRIC_KEYWORDS
                    if (!assigned) {
                        const lowerHeader = header.toLowerCase();
                        for (const category in METRIC_KEYWORDS) {
                            if (METRIC_KEYWORDS[category].some(keyword => lowerHeader.includes(keyword))) {
                                // Map keyword categories to detailed categories
                                switch (category) {
                                    case 'offensive':
                                    case 'passing':
                                    case 'goalkeeping':
                                        categories['Technical'].push(header);
                                        break;
                                    case 'defensive':
                                        categories['Tactical'].push(header);
                                        break;
                                    case 'physical':
                                        categories['Physical'].push(header);
                                        break;
                                    case 'mental':
                                        categories['Mental_Discipline'].push(header);
                                        break;
                                    case 'financial':
                                        // If financial data is present, we might need a new category or put in General
                                        categories['General'].push(header); // For now, put financial in General
                                        break;
                                }
                                assigned = true;
                                break;
                            }
                        }
                    }
                    
                    if (!assigned) {
                        // If still not assigned, put it in 'General'
                        categories['General'].push(header);
                    }
                }
            });

            // Remove duplicates within categories and sort
            for (const category in categories) {
                categories[category] = Array.from(new Set(categories[category])).sort();
            }
            return categories;
        }

        // Selects a relevant subset of metrics for display based on position and available data
        function getRelevantMetricsForPlayer(player, allPlayerData) {
            const playerPosition = player.Position;
            const availableMetricsByCategory = identifyAndCategorizeMetrics(allPlayerData);
            
            let radarMetrics = new Set();
            let barMetrics = new Set();
            let tableMetrics = new Set(); 
            let projectionMetrics = new Set(); 
            let seasonTrendsMetrics = new Set(); // New set for season trends chart

            const maxRadarMetrics = 8; 
            const maxBarMetrics = 12; 
            const maxProjectionMetrics = 3; 
            const maxSeasonTrendsMetrics = 3; // Limit season trends chart to a few key metrics

            const preferredCategories = POSITION_TO_CATEGORIES[playerPosition] || ['General'];

            // Calculate analytics for all available metrics for the current player to use for sorting
            const playerAnalytics = calculateAnalytics(player.Player_ID, allAvailableMetrics);

            // Helper to add a metric if it's a valid number for the player AND has a non-zero group average
            const addIfValidAndNonZeroAverage = (set, metric) => {
                const data = playerAnalytics[metric];
                if (data && typeof data.playerValue === 'number' && !isNaN(data.playerValue) && typeof data.average === 'number' && data.average !== 0) {
                    set.add(metric);
                    return true;
                }
                return false;
            };

            // Sort metrics based on percentile rank (higher is better, lower is better handled by inversion)
            const sortByPercentile = (a, b) => {
                const percentileA = playerAnalytics[a] ? playerAnalytics[a].percentile : -1;
                const percentileB = playerAnalytics[b] ? playerAnalytics[b].percentile : -1;
                return percentileB - percentileA; // Sort descending by percentile
            };

            // --- Populate Radar Metrics (based on user selection or default) ---
            // If there are existing selected metrics, try to keep them if valid
            const initialRadarSelection = new Set();
            if (selectedRadarMetrics.size > 0) {
                Array.from(selectedRadarMetrics).forEach(metric => {
                    if (addIfValidAndNonZeroAverage(initialRadarSelection, metric)) {
                        radarMetrics.add(metric);
                    }
                });
            }

            // Fill up with defaults if not enough selected or no previous selection
            let radarCount = radarMetrics.size;
            if (radarCount < maxRadarMetrics) {
                for (const category of preferredCategories) {
                    if (availableMetricsByCategory[category]) {
                        const sortedCategoryMetrics = [...availableMetricsByCategory[category]]
                            .filter(metric => playerAnalytics[metric] && playerAnalytics[metric].average !== 0) // Only consider metrics with non-zero group average
                            .sort(sortByPercentile); 
                        for (const metric of sortedCategoryMetrics) {
                            if (radarCount < maxRadarMetrics && !radarMetrics.has(metric)) {
                                const per90Metric = `${metric}_Per_90`;
                                if (addIfValidAndNonZeroAverage(radarMetrics, per90Metric)) {
                                    radarCount++;
                                } else if (addIfValidAndNonZeroAverage(radarMetrics, metric)) {
                                    radarCount++;
                                }
                            } else if (radarCount >= maxRadarMetrics) {
                                break; 
                            }
                        }
                    }
                    if (radarCount >= maxRadarMetrics) break;
                }
            }


            // --- Populate Bar Metrics (based on user selection or default) ---
            const initialBarSelection = new Set();
            if (selectedBarMetrics.size > 0) {
                Array.from(selectedBarMetrics).forEach(metric => {
                    if (addIfValidAndNonZeroAverage(initialBarSelection, metric)) {
                        barMetrics.add(metric);
                    }
                });
            }

            // Fill up with defaults if not enough selected or no previous selection
            let barCount = barMetrics.size;
            if (barCount < maxBarMetrics) {
                for (const category of preferredCategories) {
                    if (availableMetricsByCategory[category]) {
                        const sortedCategoryMetrics = [...availableMetricsByCategory[category]]
                            .filter(metric => playerAnalytics[metric] && playerAnalytics[metric].average !== 0) // Only consider metrics with non-zero group average
                            .sort(sortByPercentile);
                        for (const metric of sortedCategoryMetrics) {
                            if (barCount < maxBarMetrics && !barMetrics.has(metric)) {
                                const per90Metric = `${metric}_Per_90`;
                                if (addIfValidAndNonZeroAverage(barMetrics, per90Metric)) {
                                    barCount++;
                                } else if (addIfValidAndNonZeroAverage(barMetrics, metric)) {
                                    barCount++;
                                }
                            } else if (barCount >= maxBarMetrics) {
                                break;
                            }
                        }
                    }
                    if (barCount >= maxBarMetrics) break;
                }
                // Fallback to general if still not enough
                if (barCount < maxBarMetrics && availableMetricsByCategory['General']) {
                    const sortedGeneralMetrics = [...availableMetricsByCategory['General']]
                        .filter(metric => playerAnalytics[metric] && playerAnalytics[metric].average !== 0) // Only consider metrics with non-zero group average
                        .sort(sortByPercentile);
                    for (const metric of sortedGeneralMetrics) {
                        if (barCount < maxBarMetrics && !barMetrics.has(metric)) {
                            const per90Metric = `${metric}_Per_90`;
                            if (addIfValidAndNonZeroAverage(barMetrics, per90Metric)) {
                                barCount++;
                            } else if (addIfValidAndNonZeroAverage(barMetrics, metric)) {
                                barCount++;
                            }
                        } else if (barCount >= maxBarMetrics) {
                            break;
                        }
                    }
                }
            }


            // --- Populate Projection Metrics (a few key per-90 metrics for the line chart) ---
            const projectionCandidates = [];
            // Prioritize specific per-90 metrics based on position
            if (playerPosition === 'Forward' || playerPosition === 'Midfielder') {
                if (addIfValidAndNonZeroAverage(new Set(), 'Goals_Per_90')) projectionCandidates.push('Goals_Per_90');
                if (addIfValidAndNonZeroAverage(new Set(), 'Assists_Per_90')) projectionCandidates.push('Assists_Per_90');
                if (addIfValidAndNonZeroAverage(new Set(), 'Shots_Per_90')) projectionCandidates.push('Shots_Per_90');
            }
            if (playerPosition === 'Midfielder' || playerPosition === 'DEF') {
                if (addIfValidAndNonZeroAverage(new Set(), 'Tackles_Per_90')) projectionCandidates.push('Tackles_Per_90');
                if (addIfValidAndNonZeroAverage(new Set(), 'Interceptions_Per_90')) projectionCandidates.push('Interceptions_Per_90');
                if (addIfValidAndNonZeroAverage(new Set(), 'Passing_Accuracy_Pct')) projectionCandidates.push('Passing_Accuracy_Pct');
            }
            if (playerPosition === 'GKP') {
                if (addIfValidAndNonZeroAverage(new Set(), 'Saves_Per_90')) projectionCandidates.push('Saves_Per_90');
                if (addIfValidAndNonZeroAverage(new Set(), 'Goals_Conceded_Per_90')) projectionCandidates.push('Goals_Conceded_Per_90');
                if (addIfValidAndNonZeroAverage(new Set(), 'Saves_Pct')) projectionCandidates.push('Saves_Pct');
            }
            
            // Fill up to maxProjectionMetrics with other relevant per_90 metrics if needed
            if (projectionCandidates.length < maxProjectionMetrics) {
                const allPer90Metrics = allAvailableMetrics.filter(key => 
                    key.endsWith('_Per_90') && addIfValidAndNonZeroAverage(new Set(), key)
                ).sort(sortByPercentile); // Sort by percentile for projection candidates
                for (const metric of allPer90Metrics) {
                    if (projectionCandidates.length < maxProjectionMetrics && !projectionCandidates.includes(metric)) {
                        projectionCandidates.push(metric);
                    }
                }
            }
            projectionMetrics = new Set(projectionCandidates.slice(0, maxProjectionMetrics));

            // --- Populate Season Trends Metrics (a few key per-90 metrics for the line chart) ---
            const seasonTrendsCandidates = [];
            // Prioritize specific per-90 metrics based on position
            if (addIfValidAndNonZeroAverage(new Set(), 'Goals_Per_90')) seasonTrendsCandidates.push('Goals_Per_90');
            if (addIfValidAndNonZeroAverage(new Set(), 'Assists_Per_90')) seasonTrendsCandidates.push('Assists_Per_90');
            if (addIfValidAndNonZeroAverage(new Set(), 'Tackles_Per_90')) seasonTrendsCandidates.push('Tackles_Per_90');
            if (addIfValidAndNonZeroAverage(new Set(), 'Passing_Accuracy_Pct')) seasonTrendsCandidates.push('Passing_Accuracy_Pct');
            
            // Fill up to maxSeasonTrendsMetrics with other relevant per_90 metrics if needed
            if (seasonTrendsCandidates.length < maxSeasonTrendsMetrics) {
                const allPer90Metrics = allAvailableMetrics.filter(key => 
                    key.endsWith('_Per_90') && addIfValidAndNonZeroAverage(new Set(), key)
                ).sort(sortByPercentile); // Sort by percentile for season trends candidates
                for (const metric of allPer90Metrics) {
                    if (seasonTrendsCandidates.length < maxSeasonTrendsMetrics && !seasonTrendsCandidates.includes(metric)) {
                        seasonTrendsCandidates.push(metric);
                    }
                }
            }
            seasonTrendsMetrics = new Set(seasonTrendsCandidates.slice(0, maxSeasonTrendsMetrics));


            // --- Populate Table Metrics (all available numeric metrics that can be categorized for the player) ---
            // Iterate through all DETAILED_METRIC_CATEGORIES and add existing metrics for the player
            for (const categoryName in DETAILED_METRIC_CATEGORIES) {
                DETAILED_METRIC_CATEGORIES[categoryName].forEach(metric => {
                    // Only add to tableMetrics if it's valid for the player and has a non-zero group average
                    if (addIfValidAndNonZeroAverage(tableMetrics, metric)) {
                        tableMetrics.add(metric);
                    }
                });
            }
            
            // Ensure all radar and bar metrics are also included in tableMetrics for detailed breakdown
            radarMetrics.forEach(metric => tableMetrics.add(metric));
            barMetrics.forEach(metric => tableMetrics.add(metric));


            return {
                radar: Array.from(radarMetrics).sort(),
                bar: Array.from(barMetrics).sort(),
                table: Array.from(tableMetrics).sort(),
                projection: Array.from(projectionMetrics).sort(),
                seasonTrends: Array.from(seasonTrendsMetrics).sort()
            };
        }


        function calculateAnalytics(selectedPlayerId, metricsList) { // Now accepts a list of metrics to consider
            const player = playerData.find(p => p.Player_ID == selectedPlayerId);
            if (!player) return {};

            const position = player.Position;
            
            // Apply user-defined filters for peer group
            const minAge = parseInt(document.getElementById('min-age-filter').value) || 15;
            const maxAge = parseInt(document.getElementById('max-age-filter').value) || 45;
            const minMinutes = parseInt(document.getElementById('min-minutes-filter').value) || 0;

            let peerGroup = playerData.filter(p => 
                p.Player_ID != selectedPlayerId &&
                p.Season === player.Season && // Compare only with peers from the same season
                (p.Age === 'N/A' || (p.Age >= minAge && p.Age <= maxAge)) && // Apply age filter
                p.Minutes_Played >= minMinutes // Apply minutes filter
            );

            // Prioritize peer group by position, then nationality, then team if filters allow
            let initialPeerGroupSize = peerGroup.length;

            let filteredPeerGroup = peerGroup.filter(p => p.Position === player.Position);
            if (filteredPeerGroup.length < 5 && initialPeerGroupSize >= 5) { // If position filter makes it too small, broaden
                filteredPeerGroup = peerGroup.filter(p => p.Nationality === player.Nationality);
            }
            if (filteredPeerGroup.length < 5 && initialPeerGroupSize >= 5) { // If nationality filter makes it too small, broaden
                filteredPeerGroup = peerGroup.filter(p => p.Team === player.Team);
            }
            // If still too small (or original was too small), use the broadest filtered group
            if (filteredPeerGroup.length < 5) {
                filteredPeerGroup = peerGroup;
            }
            peerGroup = filteredPeerGroup;


            const results = {};

            metricsList.forEach(metric => { // Use the provided metricsList
                const playerValue = player[metric];
                // Ensure peerValues are numbers and not NaN
                const peerValues = peerGroup.map(p => p[metric]).filter(v => typeof v === 'number' && !isNaN(v));
                
                let average = 0;
                if (peerValues.length > 0) {
                    average = peerValues.reduce((a, b) => a + b, 0) / peerValues.length;
                }

                // IMPORTANT: Filter out metrics if the group average is 0.
                // This means the metric is not relevant or consistently recorded for the peer group.
                if (average === 0 && peerValues.every(val => val === 0)) { // Check if average is 0 AND all peer values are 0
                    return; // Skip this metric
                }


                let percentile = 0;
                if (peerValues.length > 0 && typeof playerValue === 'number' && !isNaN(playerValue)) {
                    const sortedPeers = [...peerValues].sort((a, b) => a - b);
                    // Find the count of peers strictly less than the player's value
                    const rank = sortedPeers.filter(v => v < playerValue).length;
                    // Calculate percentile based on rank
                    percentile = (rank / sortedPeers.length) * 100;
                }
                
                // Adjust percentile for "lower is better" metrics
                if (LOWER_IS_BETTER_METRICS.includes(metric)) {
                    percentile = 100 - percentile; // Invert percentile for these metrics
                }

                results[metric] = {
                    playerValue: playerValue,
                    average: average,
                    percentile: percentile
                };
            });
            return results;
        }

        function createOrUpdateRadarChart(analyticsData, playerName) {
            const ctx = document.getElementById('radar-chart').getContext('2d');
            const labels = Object.keys(analyticsData);
            const data = labels.map(label => analyticsData[label].percentile);

            if (radarChart) {
                radarChart.data.labels = labels;
                radarChart.data.datasets[0].data = data;
                radarChart.data.datasets[0].label = `${playerName} Percentile Rank`;
                radarChart.update();
            } else {
                radarChart = new Chart(ctx, {
                    type: 'radar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: `${playerName} Percentile Rank`,
                            data: data,
                            backgroundColor: 'rgba(56, 189, 248, 0.2)',
                            borderColor: 'rgba(14, 165, 233, 1)',
                            pointBackgroundColor: 'rgba(14, 165, 233, 1)',
                            pointBorderColor: '#fff',
                            pointHoverBackgroundColor: '#fff',
                            pointHoverBorderColor: 'rgba(14, 165, 233, 1)'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            r: {
                                beginAtZero: true,
                                max: 100,
                                ticks: {
                                    stepSize: 25,
                                    backdropColor: 'transparent',
                                    color: '#64748b'
                                },
                                grid: {
                                    color: '#e2e8f0'
                                },
                                angleLines: {
                                    color: '#e2e8f0'
                                },
                                pointLabels: {
                                    font: {
                                        size: 12
                                    },
                                    color: '#334155'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                             tooltip: {
                                enabled: false,
                                external: externalTooltipHandler
                            }
                        }
                    }
                });
            }
        }

        function createOrUpdateBarChart(analyticsData, playerName) {
            const ctx = document.getElementById('bar-chart').getContext('2d');
            const labels = Object.keys(analyticsData);
            const playerValues = labels.map(label => analyticsData[label].playerValue);
            const averageValues = labels.map(label => analyticsData[label].average);

            if (barChart) {
                barChart.data.labels = labels;
                barChart.data.datasets[0].data = playerValues;
                barChart.data.datasets[0].label = playerName;
                barChart.data.datasets[1].data = averageValues;
                barChart.update();
            } else {
                barChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: playerName,
                                data: playerValues,
                                backgroundColor: 'rgba(56, 189, 248, 0.8)',
                                borderColor: 'rgba(14, 165, 233, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Group Average',
                                data: averageValues,
                                backgroundColor: 'rgba(203, 213, 225, 0.8)',
                                borderColor: 'rgba(100, 116, 139, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                grid: {
                                    color: '#e2e8f0'
                                },
                                ticks: { color: '#64748b' }
                            },
                            x: {
                                grid: {
                                    display: false
                                },
                                ticks: { color: '#64748b' }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            tooltip: {
                                enabled: false,
                                external: externalTooltipHandler
                            }
                        }
                    }
                });
            }
        }

        function createOrUpdateScatterPlot(selectedPlayerId, metricX, metricY) {
            const ctx = document.getElementById('scatter-chart').getContext('2d');
            const scatterMessage = document.getElementById('scatter-message');

            const player = playerData.find(p => p.Player_ID === selectedPlayerId);
            if (!player) {
                scatterMessage.textContent = 'No player selected or player data not found.';
                scatterMessage.classList.remove('hidden');
                if (scatterChart) { scatterChart.destroy(); scatterChart = null; }
                return;
            }

            // Filter out players who don't have valid numeric data for both selected metrics
            const scatterData = playerData.filter(p => 
                typeof p[metricX] === 'number' && !isNaN(p[metricX]) &&
                typeof p[metricY] === 'number' && !isNaN(p[metricY])
            ).map(p => ({
                x: p[metricX],
                y: p[metricY],
                name: p.Player_Name,
                isCurrentPlayer: p.Player_ID === selectedPlayerId
            }));

            if (scatterData.length === 0) {
                scatterMessage.textContent = 'No valid data points for the selected metrics.';
                scatterMessage.classList.remove('hidden');
                if (scatterChart) { scatterChart.destroy(); scatterChart = null; }
                return;
            } else {
                scatterMessage.classList.add('hidden');
            }

            const currentPlayerPoint = scatterData.find(d => d.isCurrentPlayer);
            const otherPlayersPoints = scatterData.filter(d => !d.isCurrentPlayer);

            const datasets = [
                {
                    label: 'Other Players',
                    data: otherPlayersPoints,
                    backgroundColor: 'rgba(100, 116, 139, 0.6)', // slate-500
                    borderColor: 'rgba(100, 116, 139, 1)',
                    pointRadius: 5,
                    pointHoverRadius: 7,
                    pointHitRadius: 10,
                    pointBorderWidth: 1,
                    pointBorderColor: '#fff',
                    parsing: {
                        xAxisKey: 'x',
                        yAxisKey: 'y'
                    }
                }
            ];

            if (currentPlayerPoint) {
                datasets.push({
                    label: player.Player_Name,
                    data: [currentPlayerPoint],
                    backgroundColor: 'rgba(14, 165, 233, 0.8)', // sky-600
                    borderColor: 'rgba(14, 165, 233, 1)',
                    pointRadius: 8, // Larger point for selected player
                    pointHoverRadius: 10,
                    pointHitRadius: 15,
                    pointBorderWidth: 2,
                    pointBorderColor: '#fff',
                    parsing: {
                        xAxisKey: 'x',
                        yAxisKey: 'y'
                    }
                });
            }

            if (scatterChart) {
                scatterChart.data.labels = []; // Scatter plots don't typically use labels array
                scatterChart.data.datasets = datasets;
                scatterChart.options.scales.x.title.text = metricX.replace(/_/g, ' ');
                scatterChart.options.scales.y.title.text = metricY.replace(/_/g, ' ');
                scatterChart.update();
            } else {
                scatterChart = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                type: 'linear',
                                position: 'bottom',
                                title: {
                                    display: true,
                                    text: metricX.replace(/_/g, ' '),
                                    color: '#64748b'
                                },
                                grid: {
                                    color: '#e2e8f0'
                                },
                                ticks: { color: '#64748b' }
                            },
                            y: {
                                type: 'linear',
                                position: 'left',
                                title: {
                                    display: true,
                                    text: metricY.replace(/_/g, ' '),
                                    color: '#64748b'
                                },
                                grid: {
                                    color: '#e2e8f0'
                                },
                                ticks: { color: '#64748b' }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#334155'
                                }
                            },
                            tooltip: {
                                enabled: false,
                                external: externalTooltipHandler
                            }
                        }
                    }
                });
            }
        }


        function createOrUpdateSeasonTrendsChart(player, seasonTrendsMetrics) {
            const seasonTrendsSection = document.getElementById('season-trends-section');
            let ctxElement = document.getElementById('season-trends-chart');
            const seasonTrendsMessage = document.getElementById('season-trends-message');

            const playerHistoricalData = playerData
                .filter(d => d.Player_Name === player.Player_Name && typeof d.Season === 'number' && !isNaN(d.Season))
                .sort((a, b) => a.Season - b.Season);

            if (playerHistoricalData.length < 2 || seasonTrendsMetrics.length === 0) {
                if (seasonTrendsChart) {
                    seasonTrendsChart.destroy();
                    seasonTrendsChart = null;
                }
                seasonTrendsMessage.textContent = 'Season trends not available: Insufficient historical data (requires at least 2 seasons) or no relevant metrics selected.';
                seasonTrendsMessage.classList.remove('hidden');
                if (ctxElement) ctxElement.classList.add('hidden');
                return;
            } else {
                seasonTrendsMessage.classList.add('hidden');
                if (ctxElement) ctxElement.classList.remove('hidden');
                if (!ctxElement || !ctxElement.getContext) {
                    const container = document.getElementById('season-trends-content');
                    container.innerHTML = '<canvas id="season-trends-chart"></canvas><p id="season-trends-message" class="text-center text-slate-500 mt-8 hidden"></p>';
                    ctxElement = document.getElementById('season-trends-chart');
                }
                ctx = ctxElement.getContext('2d');
            }

            const datasets = [];
            const colors = ['#0ea5e9', '#38bdf8', '#7dd3fc', '#bae6fd', '#e0f2fe']; // Re-use colors

            const chartYears = playerHistoricalData.map(d => d.Season);

            seasonTrendsMetrics.forEach((metric, index) => {
                const dataPoints = chartYears.map(year => {
                    const dataForYear = playerHistoricalData.find(d => d.Season === year);
                    return dataForYear ? (typeof dataForYear[metric] === 'number' && !isNaN(dataForYear[metric]) ? dataForYear[metric] : 0) : 0;
                });

                datasets.push({
                    label: metric.replace(/_/g, ' '),
                    data: dataPoints,
                    borderColor: colors[index % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.3,
                    pointRadius: 4,
                    pointBackgroundColor: colors[index % colors.length],
                    pointBorderColor: '#fff',
                    pointHoverRadius: 6
                });
            });

            if (seasonTrendsChart) {
                seasonTrendsChart.data.labels = chartYears;
                seasonTrendsChart.data.datasets = datasets;
                seasonTrendsChart.update();
            } else {
                seasonTrendsChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartYears,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Per 90 Value',
                                    color: '#64748b'
                                },
                                grid: {
                                    color: '#e2e8f0'
                                },
                                ticks: { color: '#64748b' }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Season Year',
                                    color: '#64748b'
                                },
                                grid: {
                                    display: false
                                },
                                ticks: { color: '#64748b' }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#334155'
                                }
                            },
                            tooltip: {
                                enabled: false,
                                external: externalTooltipHandler
                            }
                        },
                        animation: {
                            duration: 1500,
                            easing: 'easeOutQuart',
                        }
                    }
                });
            }
        }

        function createOrUpdateProjectionChart(player, projectionMetrics) {
            const projectionSection = document.getElementById('projection-section');
            let ctxElement = document.getElementById('projection-chart');
            const projectionMessage = document.getElementById('projection-message');

            // Filter historical data for the selected player and sort by season
            const playerHistoricalData = playerData
                .filter(d => d.Player_Name === player.Player_Name && typeof d.Season === 'number' && !isNaN(d.Season))
                .sort((a, b) => a.Season - b.Season);

            // Determine if enough historical data is available for prediction
            const hasSufficientData = playerHistoricalData.length >= 2 && typeof player.Age === 'number' && !isNaN(player.Age) && projectionMetrics.length > 0;

            if (!hasSufficientData) {
                // Destroy existing chart if it exists
                if (projectionChart) {
                    projectionChart.destroy();
                    projectionChart = null;
                }
                // Show message and hide canvas
                projectionMessage.textContent = 'Prediction not available: Insufficient historical data (requires at least 2 seasons), missing player age, or no relevant metrics for projection.';
                projectionMessage.classList.remove('hidden');
                if (ctxElement) ctxElement.classList.add('hidden'); // Hide the canvas element
                // projectionSection.classList.add('hidden'); // Keep section visible to show message
                return;
            } else {
                // Show the entire section
                // projectionSection.classList.remove('hidden');
                projectionMessage.classList.add('hidden');
                if (ctxElement) ctxElement.classList.remove('hidden');
                // If canvas was destroyed, recreate it
                if (!ctxElement || !ctxElement.getContext) { // Check if canvas element is valid
                    const container = document.getElementById('projection-chart-container');
                    container.innerHTML = '<canvas id="projection-chart"></canvas><p id="projection-message" class="text-center text-slate-500 mt-8 hidden"></p>';
                    ctxElement = document.getElementById('projection-chart');
                }
                ctx = ctxElement.getContext('2d'); // Get context after ensuring canvas exists
            }

            const datasets = [];
            const colors = ['#0ea5e9', '#38bdf8', '#7dd3fc', '#bae6fd', '#e0f2fe']; 

            // Define how many past seasons to consider for the weighted average
            const numPastSeasonsForPrediction = 3; 

            // Get the two most recent historical seasons and their data
            const latestSeasonData = playerHistoricalData[playerHistoricalData.length - 1];
            const latestSeason = latestSeasonData.Season;

            // Define chart years: last two historical years + next two predicted years
            const chartYears = [];
            if (playerHistoricalData.length >= 2) {
                chartYears.push(playerHistoricalData[playerHistoricalData.length - 2].Season);
            }
            chartYears.push(latestSeason);
            chartYears.push(latestSeason + 1); // Predicted year 1
            chartYears.push(latestSeason + 2); // Predicted year 2


            projectionMetrics.forEach((metric, index) => {
                const dataPoints = [];
                const playerAge = typeof player.Age === 'number' ? player.Age : 25; // Default age if N/A

                // Get values for the relevant historical seasons for weighted average calculation
                const relevantHistoricalValues = playerHistoricalData
                    .slice(-numPastSeasonsForPrediction) // Get the last N seasons
                    .map(d => d[metric])
                    .filter(v => typeof v === 'number' && !isNaN(v));

                let basePredictionValue = 0;
                if (relevantHistoricalValues.length > 0) {
                    // Apply weighted average: more recent seasons get higher weights
                    let weightedSum = 0;
                    let totalWeight = 0;
                    for (let i = 0; i < relevantHistoricalValues.length; i++) {
                        const weight = i + 1; // Assign increasing weights to more recent seasons
                        weightedSum += relevantHistoricalValues[i] * weight;
                        totalWeight += weight;
                    }
                    basePredictionValue = weightedSum / totalWeight;
                } else {
                    // Fallback if no valid historical data for this metric
                    basePredictionValue = 0;
                }

                chartYears.forEach(year => {
                    let value;
                    const historicalRecord = playerHistoricalData.find(d => d.Season === year);

                    if (historicalRecord) {
                        // Use actual historical data
                        value = historicalRecord[metric];
                    } else {
                        // For predicted years, calculate based on weighted average + age heuristic
                        const yearsFromLatest = year - latestSeason;
                        
                        let ageMultiplier = 1.0;
                        const ageAtYear = playerAge + yearsFromLatest;

                        // Apply age-based heuristic
                        if (ageAtYear < 20) {
                            ageMultiplier = 1.0 + (0.03 * (20 - ageAtYear)); // Strong growth (e.g., 3% per year for each year below 20)
                        } else if (ageAtYear >= 20 && ageAtYear < 23) {
                            ageMultiplier = 1.0 + (0.015 * (23 - ageAtYear)); // Moderate growth
                        } else if (ageAtYear >= 23 && ageAtYear <= 28) {
                            // Peak phase: plateau
                            ageMultiplier = 1.0; 
                        } else if (ageAtYear > 28 && ageAtYear <= 32) {
                            ageMultiplier = 1.0 - (0.01 * (ageAtYear - 28)); // Slight decline
                        } else if (ageAtYear > 32) {
                            ageMultiplier = 1.0 - (0.02 * (ageAtYear - 32)); // Accelerated decline
                        }

                        value = Math.max(0, basePredictionValue * ageMultiplier); // Ensure no negative values
                    }
                    dataPoints.push(value);
                });

                datasets.push({
                    label: metric.replace(/_/g, ' '),
                    data: dataPoints,
                    borderColor: colors[index % colors.length],
                    backgroundColor: 'transparent',
                    borderWidth: 2,
                    fill: false,
                    tension: 0.3, // Smooth the line
                    pointRadius: 4,
                    pointBackgroundColor: colors[index % colors.length],
                    pointBorderColor: '#fff',
                    pointHoverRadius: 6
                });
            });

            if (projectionChart) {
                projectionChart.data.labels = chartYears;
                projectionChart.data.datasets = datasets;
                projectionChart.update();
            } else {
                projectionChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: chartYears,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                title: {
                                    display: true,
                                    text: 'Per 90 Value',
                                    color: '#64748b'
                                },
                                grid: {
                                    color: '#e2e8f0'
                                },
                                ticks: { color: '#64748b' }
                            },
                            x: {
                                title: {
                                    display: true,
                                    text: 'Season Year',
                                    color: '#64748b'
                                },
                                grid: {
                                    display: false
                                },
                                ticks: { color: '#64748b' }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    color: '#334155'
                                }
                            },
                            tooltip: {
                                enabled: false,
                                external: externalTooltipHandler
                            }
                        },
                        animation: {
                            duration: 1500,
                            easing: 'easeOutQuart',
                        }
                    }
                });
            }
        }
        
        function updateMetricsTable(analyticsData, playerName) {
            const categorizedMetricsContent = document.getElementById('categorized-metrics-table-container');
            categorizedMetricsContent.innerHTML = ''; // Clear previous content

            console.log("updateMetricsTable: currentAnalytics", analyticsData); // Debugging

            // Separate metrics into strengths and areas for development
            const strengths = [];
            const areasForDevelopment = [];
            const allCategorizedMetricsInTable = new Set(); // To keep track of metrics already placed in Strengths/Areas

            for (const metric in analyticsData) {
                const data = analyticsData[metric];
                // Only consider metrics that have a valid numeric player value and non-zero group average
                if (typeof data.playerValue === 'number' && !isNaN(data.playerValue) && typeof data.average === 'number' && data.average !== 0) {
                    if (typeof data.percentile === 'number' && !isNaN(data.percentile)) {
                        if (data.percentile >= goodPerformanceThreshold) {
                            strengths.push({ metric, ...data });
                            allCategorizedMetricsInTable.add(metric);
                        } else if (data.percentile <= poorPerformanceThreshold) {
                            areasForDevelopment.push({ metric, ...data });
                            allCategorizedMetricsInTable.add(metric);
                        }
                    }
                }
            }

            // Sort strengths and areas for development by percentile
            strengths.sort((a, b) => b.percentile - a.percentile); // Highest percentile first
            areasForDevelopment.sort((a, b) => a.percentile - b.percentile); // Lowest percentile first

            // Function to generate a collapsible category HTML block
            const generateCategoryHtml = (categoryName, metricsArray, isExpanded = false) => {
                const id = categoryName.toLowerCase().replace(/\s/g, '-') + '-metrics-table';
                const hiddenClass = isExpanded ? '' : 'hidden'; 
                const rotateClass = isExpanded ? 'rotate-180' : 'rotate-0'; 

                let html = `
                    <div class="mb-4 bg-slate-50 rounded-lg shadow-sm overflow-hidden">
                        <button class="w-full text-left p-4 font-semibold text-lg text-slate-800 bg-slate-100 hover:bg-slate-200 flex justify-between items-center toggle-category" data-target="#${id}">
                            <span>${categoryName}</span>
                            <span class="transform transition-transform duration-200 ${rotateClass}">▼</span>
                        </button>
                        <div id="${id}" class="p-4 collapsible-content ${hiddenClass}">
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-slate-200">
                                    <thead class="bg-white">
                                        <tr>
                                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Metric</th>
                                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Player Value</th>
                                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Group Average</th>
                                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Percentile Rank</th>
                                        </tr>
                                    </thead>
                                    <tbody class="bg-white divide-y divide-slate-200">
                `;
                
                let hasMetrics = false;
                metricsArray.forEach(item => {
                    let rowClass = '';
                    if (item.percentile >= goodPerformanceThreshold) {
                        rowClass = 'bg-green-50'; // Good performance
                    } else if (item.percentile <= poorPerformanceThreshold) {
                        rowClass = 'bg-red-50'; // Poor performance
                    }

                    html += `
                        <tr class="${rowClass}">
                            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">${item.metric.replace(/_/g, ' ')}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">${item.playerValue.toFixed(2)}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">${item.average.toFixed(2)}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">
                                <div class="flex items-center">
                                    <div class="w-20 bg-slate-200 rounded-full h-2.5">
                                        <div class="bg-sky-500 h-2.5 rounded-full" style="width: ${item.percentile.toFixed(0)}%"></div>
                                    </div>
                                    <span class="ml-3 font-medium">${item.percentile.toFixed(0)}%</span>
                                </div>
                            </td>
                        </tr>
                    `;
                    hasMetrics = true;
                });

                html += `
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                `;
                return hasMetrics ? html : ''; // Only return HTML if there are metrics in the category
            };

            // Add Strengths section
            if (strengths.length > 0) {
                categorizedMetricsContent.insertAdjacentHTML('beforeend', generateCategoryHtml('Strengths', strengths, true)); // Expanded by default
            }

            // Add Areas for Development section
            if (areasForDevelopment.length > 0) {
                categorizedMetricsContent.insertAdjacentHTML('beforeend', generateCategoryHtml('Areas for Development', areasForDevelopment));
            }

            // Add other detailed categories
            for (const categoryName in DETAILED_METRIC_CATEGORIES) {
                const metricsInThisCategory = DETAILED_METRIC_CATEGORIES[categoryName]
                    .filter(metric => {
                        // Only include if it's not already in strengths or areasForDevelopment,
                        // and it's a valid number for the player and its group average is not 0
                        const data = analyticsData[metric];
                        return !allCategorizedMetricsInTable.has(metric) && 
                               typeof data?.playerValue === 'number' && !isNaN(data.playerValue) &&
                               typeof data?.average === 'number' && data.average !== 0; // Check for non-zero average
                    })
                    .map(metric => ({ metric, ...analyticsData[metric] }))
                    .sort((a, b) => a.metric.localeCompare(b.metric)); // Sort alphabetically

                if (metricsInThisCategory.length > 0) {
                    categorizedMetricsContent.insertAdjacentHTML('beforeend', generateCategoryHtml(categoryName.replace(/_/g, ' '), metricsInThisCategory));
                }
            }

            // Re-attach event listeners for toggling categories as content is new
            document.querySelectorAll('.toggle-category').forEach(button => {
                button.addEventListener('click', () => {
                    const targetId = button.dataset.target;
                    const targetDiv = document.querySelector(targetId);
                    const arrow = button.querySelector('span:last-child');

                    if (targetDiv.classList.contains('hidden')) {
                        targetDiv.classList.remove('hidden');
                        targetDiv.style.maxHeight = targetDiv.scrollHeight + "px";
                        arrow.classList.remove('rotate-0');
                        arrow.classList.add('rotate-180');
                    } else {
                        targetDiv.style.maxHeight = null;
                        targetDiv.classList.add('hidden');
                        arrow.classList.remove('rotate-180');
                        arrow.classList.add('rotate-0');
                    }
                });
            });
        }
        
        const getOrCreateTooltip = (chart) => {
            let tooltipEl = chart.canvas.parentNode.querySelector('div.tooltip');

            if (!tooltipEl) {
                tooltipEl = document.createElement('div');
                tooltipEl.classList.add('tooltip', 'opacity-0', 'pointer-events-none', 'absolute', 'rounded-md', 'shadow-lg', 'transition-opacity', 'duration-200');
                
                const table = document.createElement('table');
                table.style.margin = '0px';

                tooltipEl.appendChild(table);
                chart.canvas.parentNode.appendChild(tooltipEl);
            }

            return tooltipEl;
        };

        const externalTooltipHandler = (context) => {
            const {chart, tooltip} = context;
            const tooltipEl = getOrCreateTooltip(chart);

            if (tooltip.opacity === 0) {
                tooltipEl.style.opacity = 0;
                return;
            }

            if (tooltip.body) {
                const titleLines = tooltip.title || [];
                const bodyLines = tooltip.body.map(b => b.lines);

                const tableHead = document.createElement('thead');
                
                titleLines.forEach(title => {
                    const tr = document.createElement('tr');
                    const th = document.createElement('th');
                    th.colSpan = 2;
                    th.classList.add('tooltip-title');
                    th.innerText = title;
                    tr.appendChild(th);
                    tableHead.appendChild(tr);
                });

                const tableBody = document.createElement('tbody');
                tableBody.classList.add('tooltip-body');

                bodyLines.forEach((body, i) => {
                    const colors = tooltip.labelColors[i];
                    const tr = document.createElement('tr');
                    
                    const td1 = document.createElement('td');
                    const span = document.createElement('span'); 
                    span.classList.add('tooltip-label');
                    span.style.backgroundColor = colors.backgroundColor;
                    span.style.borderColor = colors.borderColor;
                    td1.appendChild(span);

                    const td2 = document.createElement('td');
                    td2.innerText = body;

                    tr.appendChild(td1);
                    tr.appendChild(td2);
                    tableBody.appendChild(tr);
                });

                const table = tooltipEl.querySelector('table');
                while (table.firstChild) {
                    table.firstChild.remove();
                }
                table.appendChild(tableHead);
                table.appendChild(tableBody);
            }

            const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;
            tooltipEl.style.opacity = 1;
            tooltipEl.style.left = positionX + tooltip.caretX + 'px';
            tooltipEl.style.top = positionY + tooltip.caretY + 'px';
            tooltipEl.style.transform = 'translate(-50%, -110%)';
        };

        async function handleFileUpload(event) {
            const files = event.target.files;
            const fileStatus = document.getElementById('file-status');
            console.log(`Files selected: ${files.length}`); // Debugging log
            if (files.length === 0) {
                fileStatus.textContent = 'No file selected.';
                return;
            }
            fileStatus.textContent = `Processing ${files.length} file(s)...`;

            let combinedRawData = [];
            let filesProcessedCount = 0;

            for (const file of files) {
                await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            let parsedData;
                            console.log(`Reading file: ${file.name}`); // Debugging log
                            if (file.name.endsWith('.csv')) {
                                parsedData = parseCsvManually(e.target.result);
                            } else if (file.name.endsWith('.xlsx')) {
                                const data = new Uint8Array(e.target.result);
                                const workbook = XLSX.read(data, {type: 'array'});
                                const firstSheetName = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[firstSheetName];
                                parsedData = XLSX.utils.sheet_to_json(worksheet);
                            } else {
                                throw new Error(`Unsupported file type for ${file.name}.`);
                            }
                            console.log(`Parsed data from ${file.name}:`, parsedData.length, 'rows'); // Debugging log
                            combinedRawData = combinedRawData.concat(parsedData);
                            filesProcessedCount++;
                            fileStatus.textContent = `Processed ${filesProcessedCount}/${files.length} files.`;
                            resolve();
                        } catch (error) {
                            console.error(`Error processing file ${file.name}:`, error);
                            fileStatus.textContent = `Error processing ${file.name}: ${error.message}`;
                            reject(error); // Reject to stop further processing if a file fails
                        }
                    };

                    reader.onerror = function() {
                        console.error(`FileReader error for ${file.name}:`, reader.error);
                        fileStatus.textContent = `Error reading file ${file.name}: ${reader.error}`;
                        reject(reader.error);
                    };

                    if (file.name.endsWith('.xlsx')) {
                        reader.readAsArrayBuffer(file);
                    } else {
                        reader.readAsText(file);
                    }
                }).catch(() => { /* Catch and ignore individual file errors to allow others to process */ });
            }
            console.log('Total combined raw data rows:', combinedRawData.length); // Debugging log

            if (combinedRawData.length > 0) {
                playerData = cleanAndPreprocessData(combinedRawData);
                console.log('Final playerData count after cleaning:', playerData.length); // Debugging log
                populatePlayerSelect(playerData);
                populateComparisonSelects(playerData); // Populate comparison selects
                populateScatterMetricSelects(playerData); // Populate scatter plot metric selects

                // Reset selected metrics for radar/bar charts to ensure defaults are applied
                selectedRadarMetrics = new Set();
                selectedBarMetrics = new Set();
                populateMetricCheckboxes(playerData); // Populate metric selection checkboxes with defaults

                fileStatus.textContent = `All ${files.length} files loaded and processed. Select a player.`;
                document.getElementById('dashboard-content').classList.remove('hidden');
                document.getElementById('initial-message').classList.add('hidden');
                if (playerData.length > 0) {
                    document.getElementById('player-select').value = playerData[0].Player_Name; // Select first player by name
                    updateDashboard(playerData[0].Player_Name);
                } else {
                    fileStatus.textContent = `No valid player data found after processing all files. Please check file formats or ensure they are not empty.`;
                    document.getElementById('dashboard-content').classList.add('hidden');
                    document.getElementById('initial-message').classList.remove('hidden');
                }

                // Dynamically set min/max for filter options
                let overallMinAge = Infinity;
                let overallMaxAge = -Infinity;
                let overallMinMinutes = Infinity;
                let overallMaxMinutes = -Infinity; // Added for completeness

                playerData.forEach(player => {
                    if (typeof player.Age === 'number' && !isNaN(player.Age)) {
                        overallMinAge = Math.min(overallMinAge, player.Age);
                        overallMaxAge = Math.max(overallMaxAge, player.Age);
                    }
                    if (typeof player.Minutes_Played === 'number' && !isNaN(player.Minutes_Played)) {
                        overallMinMinutes = Math.min(overallMinMinutes, player.Minutes_Played);
                        overallMaxMinutes = Math.max(overallMaxMinutes, player.Minutes_Played);
                    }
                });

                const minAgeFilter = document.getElementById('min-age-filter');
                const maxAgeFilter = document.getElementById('max-age-filter');
                const minMinutesFilter = document.getElementById('min-minutes-filter');

                if (overallMinAge !== Infinity) {
                    minAgeFilter.min = Math.floor(overallMinAge);
                    minAgeFilter.max = Math.ceil(overallMaxAge); // Set max based on data
                    minAgeFilter.value = Math.floor(overallMinAge);
                } else {
                    minAgeFilter.min = 15; // Fallback
                    minAgeFilter.max = 45;
                    minAgeFilter.value = 15;
                }
                if (overallMaxAge !== -Infinity) {
                    maxAgeFilter.min = Math.floor(overallMinAge); // Set min based on data
                    maxAgeFilter.max = Math.ceil(overallMaxAge);
                    maxAgeFilter.value = Math.ceil(overallMaxAge);
                } else {
                    maxAgeFilter.min = 15;
                    maxAgeFilter.max = 45; // Fallback
                    maxAgeFilter.value = 45;
                }
                if (overallMinMinutes !== Infinity) {
                    minMinutesFilter.min = 0; // Always start from 0 minutes
                    minMinutesFilter.max = Math.ceil(overallMaxMinutes); // Set max based on data
                    minMinutesFilter.value = 0;
                } else {
                    minMinutesFilter.min = 0; // Fallback
                    minMinutesFilter.max = 10000; // Large fallback
                    minMinutesFilter.value = 0;
                }


            } else {
                fileStatus.textContent = `No valid data found in any of the uploaded files.`;
                document.getElementById('dashboard-content').classList.add('hidden');
                document.getElementById('initial-message').classList.remove('hidden');
            }
        }

        function handlePlayerSelection(event) {
            const selectedPlayerName = event.target.value;
            if (selectedPlayerName) {
                // Reset selected metrics for radar/bar charts to ensure defaults are applied
                selectedRadarMetrics = new Set();
                selectedBarMetrics = new Set();
                populateMetricCheckboxes(playerData); // Repopulate to reflect defaults
                updateDashboard(selectedPlayerName);
            }
        }

        function handleApplyFilters() {
            const selectedPlayerName = document.getElementById('player-select').value;
            if (selectedPlayerName) {
                updateDashboard(selectedPlayerName);
                // Ensure the dashboard remains visible after applying filters
                document.getElementById('dashboard-content').classList.remove('hidden');
                document.getElementById('initial-message').classList.add('hidden');
            }
        }

        function handleApplyMetricSelection() {
            const selectedRadarCheckboxes = document.querySelectorAll('#metric-checkboxes input[name="radar-metric"]:checked');
            selectedRadarMetrics = new Set(Array.from(selectedRadarCheckboxes).map(cb => cb.value));

            const selectedBarCheckboxes = document.querySelectorAll('#metric-checkboxes input[name="bar-metric"]:checked');
            selectedBarMetrics = new Set(Array.from(selectedBarCheckboxes).map(cb => cb.value));

            const selectedPlayerName = document.getElementById('player-select').value;
            if (selectedPlayerName) {
                updateDashboard(selectedPlayerName);
            }
        }

        function resetSelectedMetrics() {
            selectedRadarMetrics = new Set();
            selectedBarMetrics = new Set();
            const selectedPlayerName = document.getElementById('player-select').value;
            if (selectedPlayerName) {
                populateMetricCheckboxes(playerData); // Re-populate with defaults
                updateDashboard(selectedPlayerName); // Re-render charts
            }
        }

        function handleApplyFormatting() {
            goodPerformanceThreshold = parseInt(document.getElementById('good-threshold').value) || 75;
            poorPerformanceThreshold = parseInt(document.getElementById('poor-threshold').value) || 25;
            const selectedPlayerName = document.getElementById('player-select').value;
            if (selectedPlayerName) {
                updateMetricsTable(currentAnalytics, selectedPlayerName); // Re-render table with new thresholds
            }
        }

        async function generateScoutingReport() {
            const selectedPlayerName = document.getElementById('player-select').value;
            // Find the latest season's data for the selected player for profile and current stats
            const selectedPlayer = playerData
                .filter(p => p.Player_Name === selectedPlayerName)
                .sort((a, b) => (typeof b.Season === 'number' ? b.Season : -Infinity) - (typeof a.Season === 'number' ? a.Season : -Infinity))
                [0]; // Get the most recent season's data

            if (!selectedPlayer) {
                document.getElementById('insight-text').textContent = 'Please select a player first.';
                document.getElementById('insight-output').classList.remove('hidden');
                return;
            }

            const insightOutputDiv = document.getElementById('insight-output');
            const insightTextP = document.getElementById('insight-text');
            const insightLoadingP = document.getElementById('insight-loading');
            const generateInsightBtn = document.getElementById('generate-insight-btn');

            insightOutputDiv.classList.remove('hidden');
            insightTextP.textContent = '';
            insightLoadingP.classList.remove('hidden');
            generateInsightBtn.disabled = true;

            const playerProfile = `Player Name: ${selectedPlayer.Player_Name}\nPosition: ${selectedPlayer.Position}\nTeam: ${selectedPlayer.Team}\nNationality: ${selectedPlayer.Nationality}\nAge: ${selectedPlayer.Age}`;
            
            let metricsSummary = 'Key Metrics:\n';
            let strengthsSummary = 'Strengths (Top Performers):\n';
            let weaknessesSummary = 'Areas for Development (Bottom Performers):\n';
            let hasStrengths = false;
            let hasWeaknesses = false;

            for (const metric in currentAnalytics) {
                const data = currentAnalytics[metric];
                // Only include metrics in the LLM prompt if they have a valid numeric player value AND non-zero group average
                if (typeof data.playerValue === 'number' && !isNaN(data.playerValue) && typeof data.average === 'number' && data.average !== 0) {
                    metricsSummary += `- ${metric.replace(/_/g, ' ')}: Player Value: ${data.playerValue.toFixed(2)}, Group Average: ${data.average.toFixed(2)}, Percentile: ${data.percentile.toFixed(0)}%\n`;
                    
                    if (data.percentile >= goodPerformanceThreshold) {
                        strengthsSummary += `  - ${metric.replace(/_/g, ' ')} (${data.percentile.toFixed(0)}% percentile)\n`;
                        hasStrengths = true;
                    } else if (data.percentile <= poorPerformanceThreshold) {
                        weaknessesSummary += `  - ${metric.replace(/_/g, ' ')} (${data.percentile.toFixed(0)}% percentile)\n`;
                        hasWeaknesses = true;
                    }
                }
            }
            
            if (!hasStrengths) strengthsSummary += '  (No outstanding strengths identified based on current thresholds)\n';
            if (!hasWeaknesses) weaknessesSummary += '  (No significant areas for development identified based on current thresholds)\n';


            const prompt = `Generate a concise scouting report for the following player based on the provided data. Highlight their strengths and weaknesses relative to their peer group (same position, team, and nationality). Focus on the most impactful metrics.

${playerProfile}

${metricsSummary}

${strengthsSummary}

${weaknessesSummary}

Scouting Report:`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            // IMPORTANT: For local machine execution, you need to replace "" with your actual Gemini API Key.
            // Get your API key from Google AI Studio: https://aistudio.google.com/app/apikey
            const apiKey = "AIzaSyAFBW-1l8nWjOwXZHVj9_BNIIIv9hAYMwQ"; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    insightTextP.textContent = text;
                } else {
                    insightTextP.textContent = 'Failed to generate insight. No valid response from AI.';
                    console.error('AI response structure unexpected:', result);
                }
            } catch (error) {
                insightTextP.textContent = `Error generating insight: ${error.message}`;
                console.error('Fetch error:', error);
            } finally {
                insightLoadingP.classList.add('hidden');
                generateInsightBtn.disabled = false;
            }
        }

        function exportChartAsPng(event) {
            const chartId = event.target.dataset.chartId;
            const canvas = document.getElementById(chartId);
            if (canvas) {
                const link = document.createElement('a');
                link.download = `${chartId}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            } else {
                console.error(`Canvas with ID ${chartId} not found.`);
            }
        }

        function exportDetailedMetricsToCsv() {
            const selectedPlayerName = document.getElementById('player-select').value;
            const player = playerData.find(p => p.Player_Name === selectedPlayerName);
            if (!player) {
                alert('Please select a player first to export data.');
                return;
            }

            let csvContent = "Metric,Player Value,Group Average,Percentile Rank\n";
            
            // Collect all metrics that are displayed in the table
            const metricsToExport = [];
            for (const metric in currentAnalytics) {
                const data = currentAnalytics[metric];
                if (typeof data.playerValue === 'number' && !isNaN(data.playerValue) && typeof data.average === 'number' && data.average !== 0) {
                    metricsToExport.push({ metric, ...data });
                }
            }
            metricsToExport.sort((a,b) => a.metric.localeCompare(b.metric)); // Sort alphabetically for consistent output

            metricsToExport.forEach(item => {
                const row = [
                    `"${item.metric.replace(/_/g, ' ')}"`, // Quote metric name to handle spaces
                    item.playerValue.toFixed(2),
                    item.average.toFixed(2),
                    item.percentile.toFixed(0) + '%'
                ].join(',');
                csvContent += row + "\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection for HTML5 download attribute
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${selectedPlayerName}_detailed_metrics.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                alert('Your browser does not support downloading CSV files directly.');
            }
        }

        function handlePlayerComparison() {
            const playerNames = [];
            const select1 = document.getElementById('compare-player-1');
            const select2 = document.getElementById('compare-player-2');
            const select3 = document.getElementById('compare-player-3');
            const comparisonMessage = document.getElementById('comparison-message');

            if (select1 && select1.value) playerNames.push(select1.value);
            if (select2 && select2.value) playerNames.push(select2.value);
            if (select3 && select3.value) playerNames.push(select3.value);

            console.log("Players selected for comparison:", playerNames);

            const comparisonTableContainer = document.getElementById('comparison-table-container');
            const comparisonTable = document.getElementById('comparison-table');
            comparisonTable.innerHTML = ''; // Clear previous table content
            comparisonMessage.classList.add('hidden'); // Hide previous message

            if (playerNames.length < 2) {
                comparisonTableContainer.classList.add('hidden');
                comparisonMessage.textContent = 'Please select at least two players for comparison.';
                comparisonMessage.classList.remove('hidden');
                return;
            }

            // Ensure the comparison table container is visible
            comparisonTableContainer.classList.remove('hidden');

            // Get the latest season data for selected players
            const selectedPlayersData = playerNames.map(name => 
                playerData.filter(p => p.Player_Name === name)
                          .sort((a, b) => (typeof b.Season === 'number' ? b.Season : -Infinity) - (typeof a.Season === 'number' ? a.Season : -Infinity))
                          [0]
            ).filter(p => p); // Filter out any undefined players if not found

            console.log("Selected players data for comparison:", selectedPlayersData);

            if (selectedPlayersData.length < 2) {
                comparisonTableContainer.classList.add('hidden');
                comparisonMessage.textContent = 'Could not find data for all selected players or not enough players with valid data for comparison. Please ensure they are in the uploaded file and have valid data.';
                comparisonMessage.classList.remove('hidden');
                return;
            }

            // Determine ALL common numeric metrics across selected players
            let allCommonNumericMetrics = new Set();
            if (selectedPlayersData.length > 0) {
                Object.keys(selectedPlayersData[0]).forEach(key => {
                    const isCommonAndNumeric = selectedPlayersData.every(player => 
                        typeof player[key] === 'number' && !isNaN(player[key])
                    );
                    if (isCommonAndNumeric) {
                        allCommonNumericMetrics.add(key);
                    }
                });
            }
            allCommonNumericMetrics = Array.from(allCommonNumericMetrics).sort();
            console.log("All common numeric metrics:", allCommonNumericMetrics);


            // Categorize these common metrics for display
            const categorizedComparisonMetrics = {
                'Physical': [],
                'Technical': [],
                'Tactical': [],
                'Mental_Discipline': [],
                'General': [] // For metrics that don't fit specific categories
            };

            allCommonNumericMetrics.forEach(metric => {
                let assignedToCategory = false;
                for (const categoryName in DETAILED_METRIC_CATEGORIES) {
                    if (DETAILED_METRIC_CATEGORIES[categoryName].includes(metric)) {
                        categorizedComparisonMetrics[categoryName].push(metric);
                        assignedToCategory = true;
                        break;
                    }
                }
                if (!assignedToCategory) {
                    categorizedComparisonMetrics['General'].push(metric);
                }
            });

            // Sort metrics within each category alphabetically
            for (const category in categorizedComparisonMetrics) {
                categorizedComparisonMetrics[category].sort();
            }

            console.log("Categorized common metrics for comparison (for display):", categorizedComparisonMetrics);

            // Create table header
            let headerHtml = `
                <thead>
                    <tr class="bg-white">
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Metric</th>
            `;
            selectedPlayersData.forEach(player => {
                headerHtml += `<th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">${player.Player_Name} (${player.Team})</th>`;
            });
            headerHtml += `</tr></thead>`;
            
            let tableBodyHtml = `<tbody class="bg-white divide-y divide-slate-200">`;

            let hasAnyMetricsToDisplay = false;

            // Create table rows for each categorized common metric
            for (const categoryName in categorizedComparisonMetrics) {
                const metricsInThisCategory = categorizedComparisonMetrics[categoryName];
                if (metricsInThisCategory.length > 0) {
                    hasAnyMetricsToDisplay = true;
                    tableBodyHtml += `
                        <tr class="bg-slate-100">
                            <td colspan="${selectedPlayersData.length + 1}" class="px-6 py-3 text-left text-sm font-semibold text-slate-800">${categoryName.replace(/_/g, ' ')} Metrics</td>
                        </tr>
                    `;
                    metricsInThisCategory.forEach(metric => {
                        tableBodyHtml += `<tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">${metric.replace(/_/g, ' ')}</td>`;
                        selectedPlayersData.forEach(player => {
                            const value = player[metric];
                            tableBodyHtml += `<td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">${typeof value === 'number' && !isNaN(value) ? value.toFixed(2) : '-'}</td>`;
                        });
                        tableBodyHtml += `</tr>`;
                    });
                }
            }
            tableBodyHtml += `</tbody>`;

            if (!hasAnyMetricsToDisplay) {
                comparisonMessage.textContent = 'No common numeric metrics found for the selected players to compare across the specified categories.';
                comparisonMessage.classList.remove('hidden');
                comparisonTableContainer.classList.add('hidden'); // Ensure container is hidden if no metrics
                return;
            }

            comparisonTable.innerHTML = headerHtml + tableBodyHtml;
        }

        function handleUpdateScatterPlot() {
            const selectedPlayerName = document.getElementById('player-select').value;
            const selectedPlayer = playerData.find(p => p.Player_Name === selectedPlayerName);
            const metricX = document.getElementById('scatter-x-metric').value;
            const metricY = document.getElementById('scatter-y-metric').value;

            if (selectedPlayer && metricX && metricY) {
                createOrUpdateScatterPlot(selectedPlayer.Player_ID, metricX, metricY);
            } else {
                document.getElementById('scatter-message').textContent = 'Please select a player and both X and Y metrics.';
                document.getElementById('scatter-message').classList.remove('hidden');
                if (scatterChart) { scatterChart.destroy(); scatterChart = null; }
            }
        }

        async function downloadPdfReport() {
            const mainContent = document.getElementById('dashboard-main-content');
            if (!mainContent) {
                alert('Dashboard content not found for PDF export.');
                return;
            }

            // Temporarily expand all collapsible sections for PDF export
            const collapsibleContents = document.querySelectorAll('.collapsible-content.hidden');
            collapsibleContents.forEach(content => {
                content.classList.remove('hidden');
                content.style.maxHeight = content.scrollHeight + "px";
                const header = content.previousElementSibling;
                if (header && header.classList.contains('collapsible-header')) {
                    const arrow = header.querySelector('span:last-child');
                    if (arrow) {
                        arrow.classList.remove('rotate-0');
                        arrow.classList.add('rotate-180');
                    }
                }
            });

            // Ensure charts are rendered before capturing
            if (radarChart) radarChart.update();
            if (barChart) barChart.update();
            if (seasonTrendsChart) seasonTrendsChart.update();
            if (projectionChart) projectionChart.update();
            if (scatterChart) scatterChart.update();

            // Small delay to ensure all elements are rendered and expanded
            await new Promise(resolve => setTimeout(resolve, 500)); 

            const pdf = new window.jspdf.jsPDF('p', 'pt', 'a4'); // 'p' for portrait, 'pt' for points, 'a4' for size
            const margin = 20;
            let yOffset = margin;

            // Function to add content to PDF, handling page breaks
            const addContentToPdf = async (element) => {
                const canvas = await html2canvas(element, { scale: 2 }); // Scale for better resolution
                const imgData = canvas.toDataURL('image/png');
                const imgWidth = pdf.internal.pageSize.getWidth() - 2 * margin;
                const imgHeight = (canvas.height * imgWidth) / canvas.width;

                if (yOffset + imgHeight > pdf.internal.pageSize.getHeight() - margin) {
                    pdf.addPage();
                    yOffset = margin;
                }
                pdf.addImage(imgData, 'PNG', margin, yOffset, imgWidth, imgHeight);
                yOffset += imgHeight + 10; // Add some padding
            };

            // Capture each section individually for better control over page breaks
            const sectionsToCapture = [
                document.getElementById('introduction-section'),
                document.getElementById('how-to-use-section'),
                document.getElementById('live-scores-section'),
                document.getElementById('controls'),
                document.getElementById('player-profile-section'),
                document.getElementById('customize-charts-section'),
                document.querySelector('.grid.grid-cols-1.lg\\:grid-cols-2.gap-8.mb-8'), // Section containing radar and bar charts
                document.getElementById('scatter-plot-section'),
                document.getElementById('season-trends-section'),
                document.getElementById('projection-section'),
                document.getElementById('player-comparison-section'),
                document.getElementById('detailed-metrics-section'),
                document.getElementById('ai-insight-section'),
                document.getElementById('report-export-section') // Include the export section itself
            ].filter(Boolean); // Filter out any null elements

            for (const section of sectionsToCapture) {
                await addContentToPdf(section);
            }
            
            pdf.save('Sports_Scout_Report.pdf');

            // Revert collapsible sections to their original state after PDF generation
            collapsibleContents.forEach(content => {
                content.style.maxHeight = null;
                content.classList.add('hidden');
                const header = content.previousElementSibling;
                if (header && header.classList.contains('collapsible-header')) {
                    const arrow = header.querySelector('span:last-child');
                    if (arrow) {
                        arrow.classList.remove('rotate-180');
                        arrow.classList.add('rotate-0');
                    }
                }
            });
        }


        window.onload = () => {
            const fileUpload = document.getElementById('file-upload');
            const playerSelect = document.getElementById('player-select');
            const generateInsightBtn = document.getElementById('generate-insight-btn');
            const applyFiltersBtn = document.getElementById('apply-filters-btn');
            const applyMetricSelectionBtn = document.getElementById('apply-metric-selection-btn');
            const resetMetricsBtn = document.getElementById('reset-metrics-btn'); // New button
            const applyFormattingBtn = document.getElementById('apply-formatting-btn');
            const comparePlayersBtn = document.getElementById('compare-players-btn');
            const exportDetailedCsvBtn = document.getElementById('export-detailed-csv-btn');
            const updateScatterBtn = document.getElementById('update-scatter-btn'); // New button
            const downloadPdfBtn = document.getElementById('download-pdf-btn'); // New button

            fileUpload.addEventListener('change', handleFileUpload);
            playerSelect.addEventListener('change', handlePlayerSelection);
            generateInsightBtn.addEventListener('click', generateScoutingReport);
            applyFiltersBtn.addEventListener('click', handleApplyFilters);
            applyMetricSelectionBtn.addEventListener('click', handleApplyMetricSelection);
            resetMetricsBtn.addEventListener('click', resetSelectedMetrics); // New event listener
            applyFormattingBtn.addEventListener('click', handleApplyFormatting);
            comparePlayersBtn.addEventListener('click', handlePlayerComparison);
            exportDetailedCsvBtn.addEventListener('click', exportDetailedMetricsToCsv);
            updateScatterBtn.addEventListener('click', handleUpdateScatterPlot); // New event listener
            downloadPdfBtn.addEventListener('click', downloadPdfReport); // New event listener

            // Add event listeners for chart export buttons
            document.querySelectorAll('.export-chart-btn').forEach(button => {
                button.addEventListener('click', exportChartAsPng);
            });

            // Add event listeners for collapsible sections
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => {
                    const targetId = header.dataset.target;
                    const targetContent = document.querySelector(targetId);
                    const arrow = header.querySelector('span:last-child');

                    if (targetContent.classList.contains('hidden')) {
                        targetContent.classList.remove('hidden');
                        targetContent.style.maxHeight = targetContent.scrollHeight + "px"; // Set max-height for smooth transition
                        arrow.classList.remove('rotate-0');
                        arrow.classList.add('rotate-180');
                    } else {
                        targetContent.style.maxHeight = null;
                        targetContent.classList.add('hidden');
                        arrow.classList.remove('rotate-180');
                        arrow.classList.add('rotate-0');
                    }
                });
            });

            // Make "How to Use This Dashboard" and "Detailed Metric Breakdown" visible by default
            const howToUseHeader = document.querySelector('#how-to-use-section .collapsible-header');
            const howToUseContent = document.getElementById('how-to-use-content');
            if (howToUseHeader && howToUseContent) {
                howToUseContent.classList.remove('hidden');
                howToUseHeader.querySelector('span:last-child').classList.add('rotate-180');
                setTimeout(() => {
                    howToUseContent.style.maxHeight = howToUseContent.scrollHeight + "px";
                }, 100);
            }

            const detailedMetricsHeader = document.querySelector('#detailed-metrics-section .collapsible-header');
            const detailedMetricsContent = document.getElementById('detailed-metrics-content');
            if (detailedMetricsHeader && detailedMetricsContent) {
                detailedMetricsContent.classList.remove('hidden');
                detailedMetricsHeader.querySelector('span:last-child').classList.add('rotate-180');
                // Set max-height after a slight delay to ensure content is rendered
                setTimeout(() => {
                    detailedMetricsContent.style.maxHeight = detailedMetricsContent.scrollHeight + "px";
                }, 100);
            }

            document.getElementById('file-status').textContent = 'Awaiting file upload...'; // More explicit initial message
        };
    </script>
</body>
</html>
