<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soccer Scout Analytics Dashboard</title>
    <!-- Tailwind CSS CDN for rapid styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN for visualizations -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- SheetJS (xlsx) for Excel file parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- html2canvas for capturing DOM for PDF export -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- jsPDF for generating PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    
    <!-- Google Fonts - Inter for a clean, modern look -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    
    <!-- Custom CSS (for overrides or specific components) -->
    <link rel="stylesheet" href="css/style.css">

    <style>
        /* Basic styles for chart containers to ensure responsiveness */
        .chart-container {
            position: relative;
            margin: auto;
            height: 40vh; /* Responsive height */
            width: 100%;
            max-height: 400px; /* Max height to prevent overly tall charts on large screens */
        }
        @media (min-width: 768px) {
            .chart-container {
                height: 45vh;
                max-height: 450px;
            }
        }
        /* Styling for tooltips (Chart.js custom tooltips) */
        .tooltip {
            background-color: #334155; /* slate-700 */
            color: white;
            border-radius: 0.375rem; /* rounded-md */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            padding: 0.5rem 0.75rem;
            pointer-events: none; /* Allows clicks to pass through */
            position: absolute;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            z-index: 1000; /* Ensure it's on top */
        }
        .tooltip-title {
            font-weight: 700;
            padding-bottom: 0.25rem;
            margin-bottom: 0.25rem;
            border-bottom: 1px solid #475569; /* slate-600 */
        }
        .tooltip-body {
            font-size: 0.875rem; /* text-sm */
        }
        .tooltip-label {
            display: inline-block;
            width: 0.75rem;
            height: 0.75rem;
            margin-right: 0.5rem;
            border-radius: 0.125rem; /* rounded-sm */
        }
        /* Collapsible section styling */
        .collapsible-header {
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease-in-out;
        }
        .collapsible-content {
            max-height: 0; /* Hidden by default */
            overflow: hidden;
            transition: max-height 0.3s ease-out, padding 0.3s ease-out;
        }
        .collapsible-content.expanded {
            max-height: 1000px; /* Arbitrarily large value for expansion */
            padding-top: 1rem; /* Add padding when expanded */
            padding-bottom: 1rem;
        }
        .collapsible-header .arrow {
            transition: transform 0.2s ease-in-out;
        }
        .collapsible-header.expanded .arrow {
            transform: rotate(180deg);
        }

        /* Global Loading Overlay Styles */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0.3s ease-in-out;
        }
        #loading-overlay.visible {
            opacity: 1;
            visibility: visible;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #38bdf8; /* sky-400 */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-slate-50 text-slate-800 font-sans">

    <div id="loading-overlay">
        <div class="spinner"></div>
    </div>

    <div class="container mx-auto p-4 md:p-8">
        <!-- Header Section -->
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-slate-900">Sports Scout Analytics Dashboard</h1>
            <p class="mt-2 text-lg text-slate-600">Analyze player performance with interactive charts and AI insights.</p>
        </header>

        <main id="dashboard-main-content">
            <!-- Introduction & How-to Section -->
            <section id="intro-how-to" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                <h2 class="text-2xl font-bold text-slate-900 mb-4">Welcome to the Sports Scout Analytics Dashboard!</h2>
                <p class="text-slate-700 mb-4">
                    This interactive dashboard is designed to help you analyze soccer player performance data efficiently.
                    By uploading your CSV or Excel files, you can gain deep insights into individual players  and compare them against peers.
                </p>
                <div class="collapsible-header bg-slate-100 hover:bg-slate-200 p-3 rounded-md flex justify-between items-center text-lg font-semibold" data-target="#how-to-use-content">
                    <span>Detailed Instructions: Getting Started</span>
                    <span class="arrow">▼</span>
                </div>
                <div id="how-to-use-content" class="collapsible-content p-4 bg-slate-50 rounded-b-md">
                    <h3 class="text-xl font-bold text-slate-900 mb-3">How to Use This Dashboard:</h3>
                    <ol class="list-decimal list-inside text-slate-700 space-y-3">
                        <li>
                            <strong>Upload Your Data:</strong>
                            <p class="ml-4">Begin by uploading your player performance data. The dashboard supports both <code>.csv</code> and <code>.xlsx</code> (Excel) file formats. You can select multiple files if your data is spread across different documents. The system will process and combine them automatically.</p>
                        </li>
                        <li>
                            <strong>Select a Player:</strong>
                            <p class="ml-4">Once your data is loaded, a dropdown menu will populate with all the players found in your file(s). Choose a player to view their detailed profile and performance analytics.</p>
                        </li>
                        <li>
                            <strong>Define Your Peer Group:</strong>
                            <p class="ml-4">Use the "Peer Group Filters" to narrow down the comparison group. You can set minimum and maximum age ranges, as well as a minimum number of minutes played, to ensure you're comparing your selected player against relevant peers. Click "Apply Filters" to update the analysis.</p>
                        </li>
                        <li>
                            <strong>Customize Your Visualizations:</strong>
                            <p class="ml-4">In the "Customize Charts" section, select your desired chart type from the dropdown. Depending on the chart, you'll then be prompted to choose the specific metrics you wish to visualize. This allows for highly tailored analysis.</p>
                        </li>
                        <li>
                            <strong>Compare Players Side-by-Side:</strong>
                            <p class="ml-4">Utilize the "Player Comparison Mode" to select up to three players and view their key metrics side-by-side in a comparative table. This is ideal for scouting and recruitment decisions.</p>
                        </li>
                        <li>
                            <strong>Explore Detailed Metrics:</strong>
                            <p class="ml-4">The "Detailed Metric Breakdown" section provides a comprehensive table of all available metrics, showing the player's value, the peer group average, and their percentile rank. You can also adjust conditional formatting thresholds to quickly identify strengths and areas for development.</p>
                        </li>
                        <li>
                            <strong>Export Your Findings:</strong>
                            <p class="ml-4">Easily export individual charts as PNG images, detailed metric tables as CSV files, or download a complete PDF report of the entire dashboard for offline review or sharing.</p>
                        </li>
                    </ol>
                    <p class="text-slate-700 mt-4">We hope this dashboard empowers your scouting and analysis process!</p>
                </div>
            </section>

            <!-- File Upload and Player Selection Section -->
            <section id="controls" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                <h2 class="text-2xl font-bold text-slate-900 mb-4">Data Input & Player Selection</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                    <div>
                        <label for="file-upload" class="block text-sm font-medium text-slate-700 mb-2">1. Upload Player Data (CSV or Excel)</label>
                        <input id="file-upload" type="file" accept=".csv, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-sky-50 file:text-sky-700 hover:file:bg-sky-100 transition-colors duration-200">
                        <p id="file-status" class="text-xs text-slate-500 mt-2">No file selected.</p>
                    </div>
                    <div>
                        <label for="player-select" class="block text-sm font-medium text-slate-700 mb-2">2. Select a Player</label>
                        <select id="player-select" disabled class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500 disabled:bg-slate-100 disabled:cursor-not-allowed transition-all duration-200">
                            <option value="">Upload a file first</option>
                        </select>
                    </div>
                </div>
                
                <!-- Peer Group Filters -->
                <div class="mt-6 p-4 bg-slate-50 rounded-lg">
                    <h4 class="text-md font-semibold text-slate-800 mb-3">Peer Group Filters</h4>
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <div>
                            <label for="min-age-filter" class="block text-sm font-medium text-slate-700">Min Age</label>
                            <input type="number" id="min-age-filter" min="15" max="45" value="15" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                        </div>
                        <div>
                            <label for="max-age-filter" class="block text-sm font-medium text-slate-700">Max Age</label>
                            <input type="number" id="max-age-filter" min="15" max="45" value="45" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                        </div>
                        <div>
                            <label for="min-minutes-filter" class="block text-sm font-medium text-slate-700">Min Minutes Played</label>
                            <input type="number" id="min-minutes-filter" min="0" value="0" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                        </div>
                    </div>
                    <button id="apply-filters-btn" class="mt-4 bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">Apply Filters</button>
                </div>
            </section>

            <!-- Main Dashboard Content Area (initially hidden) -->
            <div id="dashboard-content" class="hidden">
                <!-- Player Profile Summary -->
                <section id="player-profile-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <div class="collapsible-header bg-slate-100 hover:bg-slate-200 p-3 rounded-md flex justify-between items-center text-lg font-semibold" data-target="#player-profile-content">
                        <span>Player Profile: <span id="profile-name">[Player Name]</span></span>
                        <span class="arrow">▼</span>
                    </div>
                    <div id="player-profile-content" class="collapsible-content p-4 bg-slate-50 rounded-b-md">
                        <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">
                            <div><p class="text-sm text-slate-500">Position</p><p class="text-xl font-semibold" id="profile-position">-</p></div>
                            <div><p class="text-sm text-slate-500">Team</p><p class="text-xl font-semibold" id="profile-team">-</p></div>
                            <div><p class="text-sm text-slate-500">Nationality</p><p class="text-xl font-semibold" id="profile-nationality">-</p></div>
                            <div><p class="text-sm text-slate-500">Age</p><p class="text-xl font-semibold" id="profile-age">-</p></div>
                        </div>
                    </div>
                </section>

                <!-- Chart Customization Section -->
                <section id="customize-charts-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <div class="collapsible-header bg-slate-100 hover:bg-slate-200 p-3 rounded-md flex justify-between items-center text-lg font-semibold" data-target="#customize-charts-content">
                        <span>Customize Charts</span>
                        <span class="arrow">▼</span>
                    </div>
                    <div id="customize-charts-content" class="collapsible-content p-4 bg-slate-50 rounded-b-md">
                        <h3 class="text-xl font-bold text-slate-900 mb-3">Select Chart Type & Metrics</h3>
                        
                        <div class="mb-4">
                            <label for="chart-type-select" class="block text-sm font-medium text-slate-700 mb-1">Select Chart Type</label>
                            <select id="chart-type-select" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                <option value="radar">Performance Profile (Radar Chart)</option>
                                <option value="bar">Metric Comparison (Bar Chart)</option>
                                <option value="horizontalBar">Single Metric Comparison (Horizontal Bar Chart)</option>
                                <option value="doughnut">Percentile Progress (Doughnut Chart)</option>
                                <option value="bubble">Three-Metric Comparison (Bubble Chart)</option>
                                <option value="polarArea">Metric Magnitudes (Polar Area Chart)</option>
                                <option value="line">Metric Distribution (Line Chart)</option>
                            </select>
                        </div>

                        <div id="metric-selection-area">
                            <!-- Dynamic metric selection inputs will be loaded here by JS -->
                        </div>
                        
                        <div class="flex flex-wrap gap-4 mt-4">
                            <button id="add-chart-to-dashboard-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">Add Chart to Dashboard</button>
                            <button id="reset-metrics-btn" class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">Reset Metric Selection</button>
                        </div>
                    </div>
                </section>

                <!-- Selected Visualizations Section -->
                <section id="selected-visualizations-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8 hidden">
                    <div class="collapsible-header bg-slate-100 hover:bg-slate-200 p-3 rounded-md flex justify-between items-center text-lg font-semibold" data-target="#active-charts-display-area">
                        <span>Selected Visualizations</span>
                        <span class="arrow">▼</span>
                    </div>
                    <div id="active-charts-display-area" class="collapsible-content p-4 bg-slate-50 rounded-b-md">
                        <p id="no-charts-message" class="text-center text-slate-500 mt-4">Add charts using the "Customize Charts" section above.</p>
                        <!-- Dynamic chart containers will be inserted here -->
                    </div>
                </section>

                <!-- Player Comparison Mode Section -->
                <section id="player-comparison-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mb-8">
                    <div class="collapsible-header bg-slate-100 hover:bg-slate-200 p-3 rounded-md flex justify-between items-center text-lg font-semibold" data-target="#player-comparison-content">
                        <span>Player Comparison Mode</span>
                        <span class="arrow">▼</span>
                    </div>
                    <div id="player-comparison-content" class="collapsible-content p-4 bg-slate-50 rounded-b-md">
                        <h3 class="text-xl font-bold text-slate-900 mb-3">Compare Players Side-by-Side</h3>
                        <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                            <div>
                                <label for="compare-player-1" class="block text-sm font-medium text-slate-700 mb-1">Player 1</label>
                                <select id="compare-player-1" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                    <option value="">Select Player</option>
                                </select>
                            </div>
                            <div>
                                <label for="compare-player-2" class="block text-sm font-medium text-slate-700 mb-1">Player 2</label>
                                <select id="compare-player-2" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                    <option value="">Select Player</option>
                                </select>
                            </div>
                            <div>
                                <label for="compare-player-3" class="block text-sm font-medium text-slate-700 mb-1">Player 3</label>
                                <select id="compare-player-3" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                    <option value="">Select Player</option>
                                </select>
                            </div>
                        </div>
                        <button id="compare-players-btn" class="bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">Compare Selected Players</button>
                        <div id="comparison-table-container" class="mt-6 hidden">
                            <div class="overflow-x-auto">
                                <table id="comparison-table" class="min-w-full divide-y divide-slate-200">
                                    <!-- Comparison table content will be dynamically loaded here -->
                                </table>
                                <p id="comparison-message" class="text-center text-slate-500 mt-4 hidden">Please select at least two players for comparison.</p>
                            </div>
                        </div>
                    </div>
                </section>

                <!-- Detailed Metrics Breakdown Section -->
                <section id="detailed-metrics-section" class="bg-white p-6 rounded-xl shadow-md mb-8">
                    <div class="collapsible-header bg-slate-100 hover:bg-slate-200 p-3 rounded-md flex justify-between items-center text-lg font-semibold" data-target="#detailed-metrics-content">
                        <span>Detailed Metric Breakdown</span>
                        <span class="arrow">▼</span>
                    </div>
                    <div id="detailed-metrics-content" class="collapsible-content p-4 bg-slate-50 rounded-b-md">
                        <p class="text-sm text-slate-600 mb-4">Categorized metrics showing player's value, group average, and percentile rank.</p>
                        <!-- Conditional Formatting Customization -->
                        <div class="mb-4 p-3 bg-slate-100 rounded-lg">
                            <h4 class="text-md font-semibold text-slate-800 mb-2">Conditional Formatting Thresholds</h4>
                            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                                <div>
                                    <label for="good-threshold" class="block text-sm font-medium text-slate-700">Good Performance (Percentile >=)</label>
                                    <input type="number" id="good-threshold" min="50" max="100" value="75" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                </div>
                                <div>
                                    <label for="poor-threshold" class="block text-sm font-medium text-slate-700">Poor Performance (Percentile <=)</label>
                                    <input type="number" id="poor-threshold" min="0" max="50" value="25" class="mt-1 block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                                </div>
                            </div>
                            <button id="apply-formatting-btn" class="mt-4 bg-sky-500 hover:bg-sky-600 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">Apply Formatting</button>
                        </div>

                        <div id="categorized-metrics-table-container">
                            <!-- Categories and metrics table will be dynamically inserted here -->
                        </div>
                        <button id="export-detailed-csv-btn" class="mt-4 bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full text-sm">Export Detailed Metrics as CSV</button>
                    </div>
                </section>

                <!-- AI-Powered Scouting Insight Section -->
                <section id="ai-insight-section" class="bg-white p-6 rounded-xl shadow-md">
                    <div class="collapsible-header bg-slate-100 hover:bg-slate-200 p-3 rounded-md flex justify-between items-center text-lg font-semibold" data-target="#ai-insight-content">
                        <span>✨ AI-Powered Scouting Insight</span>
                        <span class="arrow">▼</span>
                    </div>
                    <div id="ai-insight-content" class="collapsible-content p-4 bg-slate-50 rounded-b-md">
                        <p class="text-sm text-slate-600 mb-4">Generate a narrative scouting report highlighting strengths and weaknesses based on the current player's data.</p>
                        <button id="generate-insight-btn" class="bg-sky-600 hover:bg-sky-700 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200 disabled:opacity-50 disabled:cursor-not-allowed">
                            Generate Insight
                        </button>
                        <div id="insight-output" class="mt-4 p-4 bg-slate-50 rounded-lg text-slate-700 hidden">
                            <p id="insight-text" class="whitespace-pre-wrap"></p>
                            <p id="insight-loading" class="text-center text-sky-600 hidden">Generating insight...</p>
                        </div>
                    </div>
                </section>

                <!-- Report Export Section -->
                <section id="report-export-section" class="max-w-4xl mx-auto bg-white p-6 rounded-xl shadow-md mt-8">
                    <h3 class="text-xl font-bold text-slate-900 mb-3">Export Full Report</h3>
                    <p class="text-sm text-slate-600 mb-4">Download a PDF version of the entire dashboard content for offline viewing or sharing.</p>
                    <button id="download-pdf-btn" class="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-full shadow-md transition-colors duration-200">
                        Download Full Report as PDF
                    </button>
                </section>

            </div>
            <!-- Initial message when no data is loaded -->
            <div id="initial-message" class="text-center py-12">
                <p class="text-slate-500">Your interactive dashboard will appear here once you upload data.</p>
            </div>
        </main>
    </div>

    <script>
        // Global State Variables
        let playerData = []; // Stores all cleaned and preprocessed player data
        let currentAnalytics = {}; // Stores analytics for the currently selected player
        let allAvailableMetrics = []; // Stores all numeric metrics found in the dataset
        let activeCharts = {}; // Stores Chart.js instances, keyed by unique ID
        
        // Chart specific metric selections (will be updated by the new unified selection)
        let selectedChartType = 'radar'; // Default chart type for configuration
        let configuredRadarMetrics = new Set(); 
        let configuredBarMetrics = new Set();
        let configuredHorizontalBarMetric = '';
        let configuredDoughnutMetric = '';
        let configuredBubbleXMetric = '';
        let configuredBubbleYMetric = '';
        let configuredBubbleSizeMetric = '';
        let configuredPolarAreaMetrics = new Set();
        let configuredLineMetric = '';

        // Default thresholds for conditional formatting in the detailed metrics table
        let goodPerformanceThreshold = 75; // Percentile >= 75%
        let poorPerformanceThreshold = 25;  // Percentile <= 25%

        // Utility function to show/hide global loading overlay
        function showLoading(show) {
            const overlay = document.getElementById('loading-overlay');
            if (overlay) {
                if (show) {
                    overlay.classList.add('visible');
                } else {
                    overlay.classList.remove('visible');
                }
            }
        }

        // Utility function to toggle collapsible sections
        function toggleCollapsible(headerElement) {
            const targetId = headerElement.dataset.target;
            const targetContent = document.querySelector(targetId);
            const arrow = headerElement.querySelector('.arrow');

            if (targetContent && arrow) {
                const isExpanded = targetContent.classList.contains('expanded');
                if (isExpanded) {
                    targetContent.style.maxHeight = null; // Collapse
                    targetContent.classList.remove('expanded');
                    arrow.classList.remove('expanded');
                } else {
                    // Expand: Set max-height to scrollHeight to allow smooth transition
                    targetContent.style.maxHeight = targetContent.scrollHeight + "px";
                    targetContent.classList.add('expanded');
                    arrow.classList.add('expanded');
                    // After transition, remove max-height to allow content to grow if needed
                    targetContent.addEventListener('transitionend', function handler() {
                        if (targetContent.classList.contains('expanded')) {
                            targetContent.style.maxHeight = 'none';
                        }
                        targetContent.removeEventListener('transitionend', handler);
                    });
                }
            }
        }

        // Custom tooltip handler for Chart.js
        const externalTooltipHandler = (context) => {
            const {chart, tooltip} = context;
            let tooltipEl = chart.canvas.parentNode.querySelector('div.tooltip');

            if (!tooltipEl) {
                tooltipEl = document.createElement('div');
                tooltipEl.classList.add('tooltip', 'opacity-0', 'pointer-events-none', 'absolute', 'rounded-md', 'shadow-lg', 'transition-opacity', 'duration-200');
                
                const table = document.createElement('table');
                table.style.margin = '0px';

                tooltipEl.appendChild(table);
                chart.canvas.parentNode.appendChild(tooltipEl);
            }

            if (tooltip.opacity === 0) {
                tooltipEl.style.opacity = 0;
                return;
            }

            if (tooltip.body) {
                const titleLines = tooltip.title || [];
                const bodyLines = tooltip.body.map(b => b.lines);

                const tableHead = document.createElement('thead');
                
                titleLines.forEach(title => {
                    const tr = document.createElement('tr');
                    const th = document.createElement('th');
                    th.colSpan = 2;
                    th.classList.add('tooltip-title');
                    th.innerText = title;
                    tr.appendChild(th);
                    tableHead.appendChild(tr);
                });

                const tableBody = document.createElement('tbody');
                tableBody.classList.add('tooltip-body');

                bodyLines.forEach((body, i) => {
                    const colors = tooltip.labelColors[i];
                    const tr = document.createElement('tr');
                    
                    const td1 = document.createElement('td');
                    const span = document.createElement('span'); 
                    span.classList.add('tooltip-label');
                    span.style.backgroundColor = colors.backgroundColor;
                    span.style.borderColor = colors.borderColor;
                    td1.appendChild(span);

                    const td2 = document.createElement('td');
                    td2.innerText = body;

                    tr.appendChild(td1);
                    tr.appendChild(td2);
                    tableBody.appendChild(tr);
                });

                const table = tooltipEl.querySelector('table');
                while (table.firstChild) {
                    table.firstChild.remove();
                }
                table.appendChild(tableHead);
                table.appendChild(tableBody);
            }

            const {offsetLeft: positionX, offsetTop: positionY} = chart.canvas;
            tooltipEl.style.opacity = 1;
            tooltipEl.style.left = positionX + tooltip.caretX + 'px';
            tooltipEl.style.top = positionY + tooltip.caretY + 'px';
            tooltipEl.style.transform = 'translate(-50%, -110%)';
        };

        // Define constants for metric categorization and aliases
        const METRIC_KEYWORDS = {
            'offensive': [
                'goal', 'goals', 'shot', 'shots', 'assist', 'assists', 'conversion', 'xg', 'xa', 'dribble', 'dribbles', 'touches',
                'big chances missed', 'hit woodwork', 'offsides', 'carries ended with goal', 'carries ended with assist', 
                'carries ended with shot', 'carries ended with chance', 'progressive carries', 'through balls', 'crosses', 
                'successful crosses', 'fthird passes', 'successful fthird passes', 'key passes', 'chances created'
            ],
            'defensive': [
                'tackle', 'tackles', 'interception', 'interceptions', 'block', 'blocks', 'clearance', 'clearances', 
                'possession won', 'dispossessed', 'ground duels', 'gduels won', 'aerial duels', 'aduels won', 'pressure', 'pressures'
            ],
            'passing': [
                'pass', 'passes', 'successful passes', 'passes%', 'accuracy', 'through ball', 'carries', 'touches',
                'crosses', 'successful crosses', 'crosses %', 'fthird passes', 'successful fThird passes', 'fThird passes %',
                'long passes', 'short passes'
            ],
            'goalkeeping': [
                'save', 'saves', 'saves %', 'penalties saved', 'high claims', 'punches', 'goals conceded', 'xgot conceded', 
                'goals prevented', 'clearances off line', 'crosses stopped'
            ],
            'physical': [
                'minutes', 'appearances', 'sprints', 'distance covered', 'high intensity runs', 'acceleration', 'deceleration',
                'recoveries', 'duels', 'won', 'lost', 'aerial', 'ground'
            ],
            'mental': [
                'fouls', 'yellow cards', 'red cards', 'own goals', 'leadership', 'composure', 'decision making', 'errors'
            ],
            'financial': [
                'market value', 'salary', 'contract'
            ]
        };

        const POSITION_ALIASES = {
            'forward': 'Forward', 'striker': 'Forward', 'st': 'Forward', 'cf': 'Forward', 'lw': 'Forward', 'rw': 'Forward',
            'midfielder': 'Midfielder', 'mid': 'Midfielder', 'cm': 'Midfielder', 'cdm': 'Midfielder', 'cam': 'Midfielder',
            'def': 'DEF', 'defender': 'DEF', 'cb': 'DEF', 'lb': 'DEF', 'rb': 'DEF', 'lcb': 'DEF', 'rcb': 'DEF', 'lwb': 'DEF', 'rwb': 'DEF',
            'gkp': 'GKP', 'goalkeeper': 'GKP', 'gk': 'GKP'
        };

        const POSITION_TO_CATEGORIES = {
            'Forward': ['offensive', 'passing', 'physical', 'mental'],
            'Midfielder': ['passing', 'defensive', 'offensive', 'physical', 'mental'],
            'DEF': ['defensive', 'passing', 'physical', 'mental'],
            'GKP': ['goalkeeping', 'physical', 'mental'],
            'Unknown': ['offensive', 'defensive', 'passing', 'physical', 'mental']
        };

        const LOWER_IS_BETTER_METRICS = [
            'Goals_Conceded_Per_90', 'Fouls_Per_90', 'Yellow_Cards', 'Red_Cards', 'Own_Goals', 'Dispossessed_Per_90', 
            'Big_Chances_Missed_Per_90', 'Errors_Per_90'
        ];

        const BASE_METRICS_FOR_90_CONVERSION = [
            'Goals', 'Assists', 'Shots', 'Shots_On_Target', 'Tackles', 'Interceptions', 'Clearances', 'Saves',
            'Fouls', 'Yellow_Cards', 'Red_Cards', 'Own_Goals', 'Big_Chances_Missed', 'Hit_Woodwork', 'Offsides',
            'Touches', 'Passes', 'Successful_Passes', 'Crosses', 'Successful_Crosses', 'fThird_Passes', 'Successful_fThird_Passes',
            'Carries', 'Progressive_Carries', 'Carries_Ended_with_Goal', 'Carries_Ended_with_Assist', 'Carries_Ended_with_Shot',
            'Carries_Ended_with_Chance', 'Possession_Won', 'Dispossessed', 'Ground_Duels', 'gDuels_Won', 'Aerial_Duels', 'aDuels_Won',
            'Goals_Conceded', 'xGoT_Conceded', 'Goals_Prevented', 'Clearances_Off_Line', 'Punches', 'High_Claims', 'Penalties_Saved',
            'Sprints', 'Distance_Covered', 'High_Intensity_Runs', 'Fouls_Won', 'Key_Passes', 'Chances_Created',
            'Dribbles', 'Successful_Dribbles', 'Pressures', 'Successful_Pressures', 'Errors', 'Long_Passes', 'Short_Passes',
            'xA', 'xG', 'Crosses_Stopped'
        ];

        const DETAILED_METRIC_CATEGORIES = {
            'Physical': [
                'Minutes_Played', 'Appearances', 'Sprints_Per_90', 'Distance_Covered_Per_90', 'High_Intensity_Runs_Per_90',
                'Ground_Duels_Per_90', 'gDuels_Won_Per_90', 'Aerial_Duels_Per_90', 'aDuels_Won_Per_90',
                'Carries_Per_90', 'Progressive_Carries_Per_90', 'Dispossessed_Per_90'
            ],
            'Technical': [
                'Goals_Per_90', 'Assists_Per_90', 'Shots_Per_90', 'Shots_On_Target_Per_90', 'Conversion_Pct', 'xG_Per_90', 'xA_Per_90',
                'Passing_Accuracy_Pct', 'Successful_Passes_Per_90', 'Long_Passes_Per_90', 'Short_Passes_Per_90', 'Through_Balls_Per_90',
                'Crosses_Per_90', 'Successful_Crosses_Per_90', 'Touches_Per_90', 'Dribbles_Per_90', 'Successful_Dribbles_Per_90',
                'Saves_Per_90', 'Saves_Pct', 'Penalties_Saved', 'Clean_Sheets', 'Goals_Prevented', 'Clearances_Off_Line', 'Punches', 'High_Claims',
                'Crosses_Stopped_Per_90'
            ],
            'Tactical': [
                'Interceptions_Per_90', 'Tackles_Per_90', 'Blocks_Per_90', 'Clearances_Per_90', 'Possession_Won_Per_90',
                'Fouls_Won_Per_90', 'Offsides_Per_90', 'Key_Passes_Per_90', 'Chances_Created_Per_90',
                'fThird_Passes_Per_90', 'Successful_fThird_Passes_Per_90', 'xGoT_Conceded_Per_90',
                'Pressures_Per_90', 'Successful_Pressures_Per_90'
            ],
            'Mental_Discipline': [ 
                'Fouls_Per_90', 'Yellow_Cards', 'Red_Cards', 'Big_Chances_Missed_Per_90', 'Own_Goals', 'Leadership_Rating',
                'Errors_Per_90'
            ],
            'General': []
        };

        // Helper to find a column name from a list of aliases (case-insensitive)
        function findColumn(row, aliases) {
            for (const alias of aliases) {
                const foundKey = Object.keys(row).find(key => key.toLowerCase() === alias.toLowerCase());
                if (foundKey) {
                    return row[foundKey];
                }
            }
            return undefined;
        }

        // Custom CSV parsing function - more robust for quoted fields
        function parseCsvManually(csvText) {
            console.log("Parsing CSV manually...");
            const lines = csvText.trim().split(/\r?\n/); 
            if (lines.length === 0) {
                console.warn("CSV text is empty.");
                return [];
            }

            const headers = [];
            const csvSplitRegex = /,(?=(?:(?:[^"]*"){2})*[^"]*$)/;

            lines[0].split(csvSplitRegex).forEach(h => headers.push(h.trim().replace(/^"|"$/g, ''))); 
            console.log("CSV Headers:", headers);

            const data = [];
            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                if (line === '') continue; 

                const values = line.split(csvSplitRegex).map(v => v.trim().replace(/^"|"$/g, '')); 

                if (values.length !== headers.length) {
                    console.warn(`Skipping malformed row ${i + 1} due to column count mismatch: ${line}`);
                    continue;
                }
                const rowObject = {};
                headers.forEach((header, index) => {
                    rowObject[header] = values[index];
                });
                data.push(rowObject);
            }
            console.log("Parsed CSV Data (first 5 rows):", data.slice(0, 5));
            return data;
        }

        // Enhanced cleanAndPreprocessData for dynamic column handling, deduplication, and derived metrics
        function cleanAndPreprocessData(data) {
            console.log("Starting cleanAndPreprocessData. Raw data rows:", data.length);
            const processedDataMap = new Map();

            data.forEach((row, rowIndex) => {
                const newRow = {};
                newRow.Player_Name = findColumn(row, ['Player Name', 'Player', 'Name']) || 'N/A';
                
                let season = findColumn(row, ['Season', 'Year', 'Ssn']);
                if (season) {
                    season = parseInt(season);
                    if (isNaN(season)) season = 'N/A';
                } else {
                    season = 'N/A';
                }
                newRow.Season = season;

                newRow.Player_ID = `${newRow.Player_Name}_${newRow.Season}`; 

                if (processedDataMap.has(newRow.Player_ID)) {
                    console.warn(`Skipping duplicate player-season entry for: ${newRow.Player_ID} at row ${rowIndex + 1}`);
                    return; 
                }

                const rawPosition = findColumn(row, ['Position', 'Pos']);
                newRow.Position = rawPosition ? (POSITION_ALIASES[rawPosition.toLowerCase()] || 'N/A') : 'N/A';

                newRow.Team = findColumn(row, ['Club', 'Team']) || 'N/A';
                newRow.Nationality = findColumn(row, ['Nationality']) || 'N/A';
                
                const rawAge = findColumn(row, ['Age']);
                newRow.Age = parseFloat(rawAge); 
                if (isNaN(newRow.Age)) newRow.Age = 'N/A';

                const rawMinutes = findColumn(row, ['Minutes', 'Min', 'MP']);
                newRow.Minutes_Played = parseFloat(rawMinutes);
                if (isNaN(newRow.Minutes_Played)) newRow.Minutes_Played = 0;
                
                for (const key in row) {
                    const cleanedKey = key.replace(/[^a-zA-Z0-9_]/g, '_').replace(/_{2,}/g, '_').replace(/_$/, '');
                    if (!(cleanedKey in newRow) && row[key] !== '') { 
                        const value = parseFloat(row[key]);
                        newRow[cleanedKey] = isNaN(value) ? row[key] : value;
                    }
                }

                const minutes = newRow.Minutes_Played;

                BASE_METRICS_FOR_90_CONVERSION.forEach(metricKey => {
                    let rawValue = newRow[metricKey];
                    const aliasesMap = {
                        'Goals': ['Gls'], 'Assists': ['Ast'], 'Shots_On_Target': ['SoT'], 'Goals_Conceded': ['GC'],
                        'Yellow_Cards': ['Yellow Cards'], 'Red_Cards': ['Red Cards'], 'Own_Goals': ['Own Goals'],
                        'Big_Chances_Missed': ['Big Chances Missed'], 'Hit_Woodwork': ['Hit Woodwork'], 'Offsides': ['Offsides'],
                        'Touches': ['Touches'], 'Passes': ['Passes'], 'Successful_Passes': ['Successful Passes'],
                        'Crosses': ['Crosses'], 'Successful_Crosses': ['Successful Crosses'],
                        'fThird_Passes': ['fThird Passes'], 'Successful_fThird_Passes': ['Successful fThird Passes'],
                        'Carries': ['Carries'], 'Progressive_Carries': ['Progressive Carries'],
                        'Carries_Ended_with_Goal': ['Carries Ended with Goal'], 'Carries_Ended_with_Assist': ['Carries Ended with Assist'],
                        'Carries_Ended_with_Shot': ['Carries Ended with Shot'], 'Carries_Ended_with_Chance': ['Carries Ended with Chance'],
                        'Possession_Won': ['Possession Won'], 'Dispossessed': ['Dispossessed'],
                        'Ground_Duels': ['Ground Duels'], 'gDuels_Won': ['gDuels Won'],
                        'Aerial_Duels': ['Aerial Duels'], 'aDuels_Won': ['aDuels Won'], 'Fouls': ['Fouls'],
                        'xGoT_Conceded': ['xGoT Conceded'], 'Goals_Prevented': ['Goals Prevented'], 'Clearances_Off_Line': ['Clearances Off Line'],
                        'Punches': ['Punches'], 'High_Claims': ['High Claims'], 'Penalties_Saved': ['Penalties Saved'],
                        'Sprints': ['Sprints'], 'Distance_Covered': ['Distance Covered'], 'High_Intensity_Runs': ['High Intensity Runs'],
                        'Fouls_Won': ['Fouls Won'], 'Key_Passes': ['Key Passes'], 'Chances_Created': ['Chances Created'],
                        'Dribbles': ['Dribbles'], 'Successful_Dribbles': ['Successful Dribbles'], 'Pressures': ['Pressures'],
                        'Successful_Pressures': ['Successful Pressures'], 'Errors': ['Errors'], 'Long_Passes': ['Long Passes'],
                        'Short_Passes': ['Short Passes'], 'xA': ['xA'], 'xG': ['xG'], 'Crosses_Stopped': ['Crosses Stopped']
                    };

                    if (rawValue === undefined && aliasesMap[metricKey]) {
                        for (const alias of aliasesMap[metricKey]) {
                            const foundAliasKey = Object.keys(newRow).find(key => key.toLowerCase() === alias.toLowerCase());
                            if (foundAliasKey) {
                                rawValue = newRow[foundAliasKey];
                                break;
                            }
                        }
                    }

                    if (typeof rawValue === 'number' && minutes > 0) {
                        newRow[`${metricKey}_Per_90`] = (rawValue / minutes) * 90;
                    } else {
                        newRow[`${metricKey}_Per_90`] = 0;
                    }
                });

                if (typeof newRow.Shots === 'number' && newRow.Shots > 0 && typeof newRow.Shots_On_Target === 'number') {
                    newRow.Shots_on_Target_Pct = (newRow.Shots_On_Target / newRow.Shots) * 100;
                } else {
                    newRow.Shots_on_Target_Pct = 0;
                }
                
                if (typeof newRow.Saves === 'number' && newRow.Saves > 0 && typeof newRow.Goals_Conceded === 'number') {
                    newRow.Saves_Pct = (newRow.Saves / (newRow.Saves + newRow.Goals_Conceded)) * 100;
                } else if (newRow['Saves_Pct'] !== undefined) { 
                    newRow.Saves_Pct = parseFloat(newRow['Saves_Pct']) || 0;
                } else {
                    newRow.Saves_Pct = 0;
                }

                if (newRow['Passes%'] !== undefined) {
                    newRow.Passing_Accuracy_Pct = parseFloat(newRow['Passes%']) || 0;
                } else if (typeof newRow.Successful_Passes === 'number' && typeof newRow.Passes === 'number' && newRow.Passes > 0) {
                    newRow.Passing_Accuracy_Pct = (newRow.Successful_Passes / newRow.Passes) * 100;
                } else {
                    newRow.Passing_Accuracy_Pct = 0;
                }

                processedDataMap.set(newRow.Player_ID, newRow);
            });
            console.log("Processed data map size:", processedDataMap.size);
            const finalProcessedData = Array.from(processedDataMap.values());
            console.log("Cleaned and Preprocessed Data (first 5 rows):", finalProcessedData.slice(0, 5));
            return finalProcessedData;
        }

        function populatePlayerSelect(data) {
            console.log("Populating player select dropdown with data:", data.length, "players.");
            const playerSelect = document.getElementById('player-select');
            playerSelect.innerHTML = '';
            playerSelect.disabled = false;

            if (data.length === 0) {
                const option = document.createElement('option');
                option.textContent = 'No players found in file';
                playerSelect.appendChild(option);
                playerSelect.disabled = true;
                return;
            }
            
            const uniquePlayers = new Map();
            data.forEach(player => {
                // Prioritize latest season if available
                if (!uniquePlayers.has(player.Player_Name) || 
                    (typeof player.Season === 'number' && typeof uniquePlayers.get(player.Player_Name).Season === 'number' && player.Season > uniquePlayers.get(player.Player_Name).Season) ||
                    (uniquePlayers.get(player.Player_Name).Season === 'N/A' && typeof player.Season === 'number')
                    ) {
                    uniquePlayers.set(player.Player_Name, player);
                }
            });

            const sortedPlayers = Array.from(uniquePlayers.values()).sort((a, b) => {
                const nameA = a.Player_Name ? a.Player_Name.toUpperCase() : '';
                const nameB = b.Player_Name ? b.Player_Name.toUpperCase() : '';
                if (nameA < nameB) return -1;
                if (nameA > nameB) return 1;
                return 0;
            });

            sortedPlayers.forEach(player => {
                const option = document.createElement('option');
                option.value = player.Player_Name;
                option.textContent = `${player.Player_Name} (${player.Team}${player.Season !== 'N/A' ? `, ${player.Season}` : ''})`;
                playerSelect.appendChild(option);
            });
            console.log("Player select dropdown populated.");
        }

        function populateComparisonSelects(data) {
            console.log("Populating comparison selects with data for", data.length, "players.");
            const compareSelect1 = document.getElementById('compare-player-1');
            const compareSelect2 = document.getElementById('compare-player-2');
            const compareSelect3 = document.getElementById('compare-player-3');

            [compareSelect1, compareSelect2, compareSelect3].forEach(select => {
                if (select) {
                    select.innerHTML = '<option value="">Select Player</option>';
                    const uniquePlayers = new Map();
                    data.forEach(player => {
                        if (!uniquePlayers.has(player.Player_Name)) {
                            uniquePlayers.set(player.Player_Name, player);
                        }
                    });
                    const sortedPlayers = Array.from(uniquePlayers.values()).sort((a, b) => a.Player_Name.localeCompare(b.Player_Name));
                    sortedPlayers.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.Player_Name;
                        option.textContent = `${player.Player_Name} (${player.Team})`;
                        select.appendChild(option);
                    });
                }
            });
            console.log("Comparison selects populated.");
        }

        function populateMetricSelectionUI(chartType) {
            const metricSelectionArea = document.getElementById('metric-selection-area');
            metricSelectionArea.innerHTML = ''; // Clear previous inputs

            const selectedPlayerName = document.getElementById('player-select').value;
            const selectedPlayer = playerData.find(p => p.Player_Name === selectedPlayerName);

            // Filter metrics to only include those that are numeric and non-zero for the selected player
            const relevantNumericMetrics = allAvailableMetrics.filter(metric => 
                selectedPlayer && typeof selectedPlayer[metric] === 'number' && !isNaN(selectedPlayer[metric]) && selectedPlayer[metric] !== 0
            ).sort();

            const createMetricDropdown = (id, labelText, selectedValue = '') => {
                const div = document.createElement('div');
                div.classList.add('mb-4');
                div.innerHTML = `
                    <label for="${id}" class="block text-sm font-medium text-slate-700 mb-1">${labelText}</label>
                    <select id="${id}" class="block w-full p-2 border border-slate-300 rounded-md shadow-sm focus:ring-sky-500 focus:border-sky-500">
                        <option value="">Select Metric</option>
                    </select>
                `;
                const select = div.querySelector('select');
                relevantNumericMetrics.forEach(metric => {
                    const option = document.createElement('option');
                    option.value = metric;
                    option.textContent = metric.replace(/_/g, ' ');
                    select.appendChild(option);
                });
                if (selectedValue && relevantNumericMetrics.includes(selectedValue)) {
                    select.value = selectedValue;
                }
                metricSelectionArea.appendChild(div);
            };

            const createMetricCheckboxes = (namePrefix, labelText, selectedMetricsSet) => {
                const div = document.createElement('div');
                div.classList.add('mb-4');
                div.innerHTML = `<label class="block text-sm font-medium text-slate-700 mb-2">${labelText}</label><div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2" id="${namePrefix}-checkboxes"></div>`;
                const checkboxesContainer = div.querySelector(`#${namePrefix}-checkboxes`);
                
                relevantNumericMetrics.forEach(metric => {
                    const checkboxDiv = document.createElement('div');
                    checkboxDiv.classList.add('flex', 'items-center');
                    const input = document.createElement('input');
                    input.type = 'checkbox';
                    input.id = `${namePrefix}-${metric}`;
                    input.name = `${namePrefix}-metric`;
                    input.value = metric;
                    input.classList.add('form-checkbox', 'h-4', 'w-4', 'text-sky-600', 'rounded', 'focus:ring-sky-500');
                    if (selectedMetricsSet.has(metric)) {
                        input.checked = true;
                    }
                    const label = document.createElement('label');
                    label.htmlFor = `${namePrefix}-${metric}`;
                    label.classList.add('ml-2', 'text-sm', 'text-slate-700');
                    label.textContent = metric.replace(/_/g, ' ');
                    checkboxDiv.appendChild(input);
                    checkboxDiv.appendChild(label); // Append the label to the div
                    checkboxesContainer.appendChild(checkboxDiv);
                });
                metricSelectionArea.appendChild(div);
            };

            switch (chartType) {
                case 'radar':
                    createMetricCheckboxes('radar', 'Select Metrics for Radar Chart (up to 8)', configuredRadarMetrics);
                    break;
                case 'bar':
                    createMetricCheckboxes('bar', 'Select Metrics for Bar Chart (up to 12)', configuredBarMetrics);
                    break;
                case 'horizontalBar':
                    createMetricDropdown('horizontal-bar-metric', 'Select Metric for Horizontal Bar Chart', configuredHorizontalBarMetric);
                    break;
                case 'doughnut':
                    createMetricDropdown('doughnut-metric', 'Select Metric for Doughnut Chart (Percentile Progress)', configuredDoughnutMetric);
                    break;
                case 'bubble':
                    createMetricDropdown('bubble-x-metric', 'X-Axis Metric for Bubble Chart', configuredBubbleXMetric);
                    createMetricDropdown('bubble-y-metric', 'Y-Axis Metric for Bubble Chart', configuredBubbleYMetric);
                    createMetricDropdown('bubble-size-metric', 'Size Metric for Bubble Chart', configuredBubbleSizeMetric);
                    break;
                case 'polarArea':
                    createMetricCheckboxes('polar-area', 'Select Metrics for Polar Area Chart (up to 8)', configuredPolarAreaMetrics);
                    break;
                case 'line':
                    createMetricDropdown('line-metric', 'Select Metric for Line Chart (Distribution)', configuredLineMetric);
                    break;
                default:
                    break;
            }
        }

        function updateDashboard(selectedPlayerName) {
            console.log("Updating dashboard for player:", selectedPlayerName);
            const selectedPlayer = playerData
                .filter(p => p.Player_Name === selectedPlayerName)
                .sort((a, b) => (typeof b.Season === 'number' ? b.Season : -Infinity) - (typeof a.Season === 'number' ? a.Season : -Infinity))
                [0];

            if (!selectedPlayer) {
                console.error("Selected player not found in playerData:", selectedPlayerName);
                return;
            }

            updateProfile(selectedPlayer);
            
            // Re-calculate all relevant analytics for the detailed table and AI insight
            const allRelevantMetricsForAnalytics = new Set();
            for (const category in DETAILED_METRIC_CATEGORIES) {
                DETAILED_METRIC_CATEGORIES[category].forEach(metric => {
                    if (typeof selectedPlayer[metric] === 'number' && !isNaN(selectedPlayer[metric])) {
                        allRelevantMetricsForAnalytics.add(metric);
                    }
                });
            }
            currentAnalytics = calculateAnalytics(selectedPlayer.Player_ID, Array.from(allRelevantMetricsForAnalytics));
            updateMetricsTable(currentAnalytics, selectedPlayer.Player_Name);

            // Re-populate metric selection UI based on the new player
            populateMetricSelectionUI(selectedChartType);
            
            document.getElementById('insight-output').classList.add('hidden');
            document.getElementById('insight-text').textContent = '';
            console.log("Dashboard updated.");
        }

        function addChartToDashboard() {
            const selectedPlayerName = document.getElementById('player-select').value;
            const selectedPlayer = playerData.find(p => p.Player_Name === selectedPlayerName);

            if (!selectedPlayer) {
                const messageBox = document.createElement('div');
                messageBox.classList.add('fixed', 'top-1/2', 'left-1/2', '-translate-x-1/2', '-translate-y-1/2', 'bg-red-500', 'text-white', 'p-4', 'rounded-lg', 'shadow-lg', 'z-[10000]');
                messageBox.textContent = 'Please select a player first to add a chart.';
                document.body.appendChild(messageBox);
                setTimeout(() => messageBox.remove(), 3000);
                return;
            }

            const activeChartsDisplayArea = document.getElementById('active-charts-display-area');
            document.getElementById('selected-visualizations-section').classList.remove('hidden');
            document.getElementById('no-charts-message').classList.add('hidden');

            const chartId = `${selectedChartType}-${Date.now()}`; // Unique ID for each chart instance
            let chartTitle = '';
            let chartDescription = '';
            let chartDataValid = true;

            // Create chart wrapper div
            const chartWrapper = document.createElement('div');
            chartWrapper.id = `chart-wrapper-${chartId}`;
            chartWrapper.classList.add('bg-white', 'p-6', 'rounded-xl', 'shadow-md', 'mb-8', 'border', 'border-slate-200');
            
            // Determine chart title and description based on selectedChartType
            switch (selectedChartType) {
                case 'radar':
                    chartTitle = 'Performance Profile (Radar Chart)';
                    chartDescription = "Player's percentile rank vs peers in the same position (per 90 minutes).";
                    const radarMetrics = Array.from(document.querySelectorAll('#radar-checkboxes input[name="radar-metric"]:checked')).map(cb => cb.value);
                    if (radarMetrics.length === 0) chartDataValid = false;
                    configuredRadarMetrics = new Set(radarMetrics); // Save configuration
                    break;
                case 'bar':
                    chartTitle = 'Metric Comparison (Bar Chart)';
                    chartDescription = "Player's raw metric values (per 90 minutes) compared to the average of their peer group.";
                    const barMetrics = Array.from(document.querySelectorAll('#bar-checkboxes input[name="bar-metric"]:checked')).map(cb => cb.value);
                    if (barMetrics.length === 0) chartDataValid = false;
                    configuredBarMetrics = new Set(barMetrics); // Save configuration
                    break;
                case 'horizontalBar':
                    chartTitle = 'Single Metric Comparison (Horizontal Bar Chart)';
                    chartDescription = "Player's value vs. peer average for a selected metric.";
                    configuredHorizontalBarMetric = document.getElementById('horizontal-bar-metric').value;
                    if (!configuredHorizontalBarMetric) chartDataValid = false;
                    break;
                case 'doughnut':
                    chartTitle = 'Percentile Progress (Doughnut Chart)';
                    chartDescription = "Visualizes the player's percentile rank for a single chosen metric.";
                    configuredDoughnutMetric = document.getElementById('doughnut-metric').value;
                    if (!configuredDoughnutMetric) chartDataValid = false;
                    break;
                case 'bubble':
                    chartTitle = 'Three-Metric Comparison (Bubble Chart)';
                    chartDescription = "Compares players based on two metrics (X, Y) with a third metric influencing bubble size.";
                    configuredBubbleXMetric = document.getElementById('bubble-x-metric').value;
                    configuredBubbleYMetric = document.getElementById('bubble-y-metric').value;
                    configuredBubbleSizeMetric = document.getElementById('bubble-size-metric').value;
                    if (!configuredBubbleXMetric || !configuredBubbleYMetric || !configuredBubbleSizeMetric) chartDataValid = false;
                    break;
                case 'polarArea':
                    chartTitle = 'Metric Magnitudes (Polar Area Chart)';
                    chartDescription = "Displays the magnitude of multiple selected metrics for the player.";
                    const polarAreaMetrics = Array.from(document.querySelectorAll('#polar-area-checkboxes input[name="polar-area-metric"]:checked')).map(cb => cb.value);
                    if (polarAreaMetrics.length === 0) chartDataValid = false;
                    configuredPolarAreaMetrics = new Set(polarAreaMetrics); // Save configuration
                    break;
                case 'line':
                    chartTitle = 'Metric Distribution (Line Chart)';
                    chartDescription = "Shows the values of a single metric across all players in the dataset.";
                    configuredLineMetric = document.getElementById('line-metric').value;
                    if (!configuredLineMetric) chartDataValid = false;
                    break;
                default:
                    chartDataValid = false;
                    break;
            }

            if (!chartDataValid) {
                 const messageBox = document.createElement('div');
                messageBox.classList.add('fixed', 'top-1/2', 'left-1/2', '-translate-x-1/2', '-translate-y-1/2', 'bg-red-500', 'text-white', 'p-4', 'rounded-lg', 'shadow-lg', 'z-[10000]');
                messageBox.textContent = 'Please select all required metrics for the chosen chart type.';
                document.body.appendChild(messageBox);
                setTimeout(() => messageBox.remove(), 3000);
                return;
            }

            chartWrapper.innerHTML = `
                <h3 class="text-xl font-bold text-slate-900 mb-2">${chartTitle}</h3>
                <p class="text-sm text-slate-600 mb-4">${chartDescription}</p>
                <div class="chart-container"><canvas id="${chartId}"></canvas></div>
                <p id="message-${chartId}" class="text-center text-slate-500 mt-4 hidden">No data to display this chart.</p>
                <div class="flex flex-wrap gap-2 mt-4">
                    <button class="bg-slate-200 hover:bg-slate-300 text-slate-800 font-bold py-2 px-4 rounded-full text-sm export-chart-btn" data-chart-id="${chartId}">Export Chart as PNG</button>
                    <button class="bg-red-500 hover:bg-red-600 text-white font-bold py-2 px-4 rounded-full text-sm remove-chart-btn" data-chart-id="${chartId}">Remove Chart</button>
                </div>
            `;
            activeChartsDisplayArea.appendChild(chartWrapper);

            const ctx = document.getElementById(chartId).getContext('2d');
            let newChartInstance = null;

            switch (selectedChartType) {
                case 'radar':
                    newChartInstance = createRadarChart(ctx, calculateAnalytics(selectedPlayer.Player_ID, Array.from(configuredRadarMetrics)), selectedPlayer.Player_Name);
                    break;
                case 'bar':
                    newChartInstance = createBarChart(ctx, calculateAnalytics(selectedPlayer.Player_ID, Array.from(configuredBarMetrics)), selectedPlayer.Player_Name);
                    break;
                case 'horizontalBar':
                    newChartInstance = createHorizontalBarChart(ctx, selectedPlayer.Player_ID, configuredHorizontalBarMetric);
                    break;
                case 'doughnut':
                    newChartInstance = createDoughnutChart(ctx, selectedPlayer.Player_ID, configuredDoughnutMetric);
                    break;
                case 'bubble':
                    newChartInstance = createBubbleChart(ctx, selectedPlayer.Player_ID, configuredBubbleXMetric, configuredBubbleYMetric, configuredBubbleSizeMetric);
                    break;
                case 'polarArea':
                    newChartInstance = createPolarAreaChart(ctx, calculateAnalytics(selectedPlayer.Player_ID, Array.from(configuredPolarAreaMetrics)), selectedPlayer.Player_Name);
                    break;
                case 'line':
                    newChartInstance = createLineChart(ctx, selectedPlayer.Player_ID, configuredLineMetric);
                    break;
            }

            if (newChartInstance) {
                activeCharts[chartId] = newChartInstance;
                // Attach event listeners to the new buttons
                chartWrapper.querySelector('.export-chart-btn').addEventListener('click', exportChartAsPng);
                chartWrapper.querySelector('.remove-chart-btn').addEventListener('click', (event) => removeChartFromDashboard(event.target.dataset.chartId));
            } else {
                document.getElementById(`message-${chartId}`).classList.remove('hidden');
            }
        }

        function removeChartFromDashboard(chartId) {
            if (activeCharts[chartId]) {
                activeCharts[chartId].destroy();
                delete activeCharts[chartId];
            }
            const chartWrapper = document.getElementById(`chart-wrapper-${chartId}`);
            if (chartWrapper) {
                chartWrapper.remove();
            }
            if (Object.keys(activeCharts).length === 0) {
                document.getElementById('no-charts-message').classList.remove('hidden');
                document.getElementById('selected-visualizations-section').classList.add('hidden');
            }
        }

        function updateProfile(player) {
            console.log("Updating player profile for:", player.Player_Name);
            document.getElementById('profile-name').textContent = player.Player_Name || 'N/A';
            document.getElementById('profile-position').textContent = player.Position || 'N/A';
            document.getElementById('profile-team').textContent = player.Team || 'N/A';
            document.getElementById('profile-nationality').textContent = player.Nationality || 'N/A';
            document.getElementById('profile-age').textContent = player.Age || 'N/A';
        }

        function identifyAndCategorizeMetrics(data) {
            if (data.length === 0) return {};

            const categories = {
                'Physical': [], 'Technical': [], 'Tactical': [], 'Mental_Discipline': [], 'General': []
            };

            let allHeaders = new Set();
            data.forEach(row => {
                Object.keys(row).forEach(key => allHeaders.add(key));
            });
            allHeaders = Array.from(allHeaders);

            allHeaders.forEach(header => {
                const hasMeaningfulNumericData = data.some(row => 
                    typeof row[header] === 'number' && !isNaN(row[header]) && row[header] !== 0
                );
                if (hasMeaningfulNumericData) {
                    let assigned = false;
                    for (const categoryName in DETAILED_METRIC_CATEGORIES) {
                        if (DETAILED_METRIC_CATEGORIES[categoryName].includes(header)) {
                            categories[categoryName].push(header);
                            assigned = true;
                            break;
                        }
                    }

                    if (!assigned) {
                        const lowerHeader = header.toLowerCase();
                        for (const category in METRIC_KEYWORDS) {
                            if (METRIC_KEYWORDS[category].some(keyword => lowerHeader.includes(keyword))) {
                                switch (category) {
                                    case 'offensive':
                                    case 'passing':
                                    case 'goalkeeping':
                                        categories['Technical'].push(header);
                                        break;
                                    case 'defensive':
                                        categories['Tactical'].push(header);
                                        break;
                                    case 'physical':
                                        categories['Physical'].push(header);
                                        break;
                                    case 'mental':
                                        categories['Mental_Discipline'].push(header);
                                        break;
                                    case 'financial':
                                        categories['General'].push(header);
                                        break;
                                }
                                assigned = true;
                                break;
                            }
                        }
                    }
                    
                    if (!assigned) {
                        categories['General'].push(header);
                    }
                }
            });

            for (const category in categories) {
                categories[category] = Array.from(new Set(categories[category])).sort();
            }
            return categories;
        }

        function getRelevantMetricsForPlayer(player, allPlayerData, chartType) {
            const playerPosition = player.Position;
            const availableMetricsByCategory = identifyAndCategorizeMetrics(allPlayerData);
            
            let metricsSet = new Set(); 

            const maxMetrics = {
                radar: 8,
                bar: 12,
                polarArea: 8
            };

            const preferredCategories = POSITION_TO_CATEGORIES[playerPosition] || ['General'];

            const playerAnalytics = calculateAnalytics(player.Player_ID, allAvailableMetrics);

            const addIfValidAndNonZeroAverage = (set, metric) => {
                const data = playerAnalytics[metric];
                if (data && typeof data.playerValue === 'number' && !isNaN(data.playerValue) && typeof data.average === 'number' && data.average !== 0) {
                    set.add(metric);
                    return true;
                }
                return false;
            };

            const sortByPercentile = (a, b) => {
                const percentileA = playerAnalytics[a] ? playerAnalytics[a].percentile : -1;
                const percentileB = playerAnalytics[b] ? playerAnalytics[b].percentile : -1;
                return percentileB - percentileA;
            };

            let currentConfiguredMetrics;
            switch(chartType) {
                case 'radar': currentConfiguredMetrics = configuredRadarMetrics; break;
                case 'bar': currentConfiguredMetrics = configuredBarMetrics; break;
                case 'polarArea': currentConfiguredMetrics = configuredPolarAreaMetrics; break;
                default: currentConfiguredMetrics = new Set(); break; // For single-metric or specific charts
            }

            // Populate with previously configured metrics first
            if (currentConfiguredMetrics.size > 0) {
                Array.from(currentConfiguredMetrics).forEach(metric => {
                    if (addIfValidAndNonZeroAverage(metricsSet, metric)) {
                        // Keep track of count if it's a multi-metric chart
                    }
                });
            }

            let currentCount = metricsSet.size;
            const limit = maxMetrics[chartType] || Infinity;

            if (currentCount < limit) {
                for (const category of preferredCategories) {
                    if (availableMetricsByCategory[category]) {
                        const sortedCategoryMetrics = [...availableMetricsByCategory[category]]
                            .filter(metric => playerAnalytics[metric] && playerAnalytics[metric].average !== 0)
                            .sort(sortByPercentile); 
                        for (const metric of sortedCategoryMetrics) {
                            if (currentCount < limit && !metricsSet.has(metric)) {
                                const per90Metric = `${metric}_Per_90`;
                                if (addIfValidAndNonZeroAverage(metricsSet, per90Metric)) {
                                    currentCount++;
                                } else if (addIfValidAndNonZeroAverage(metricsSet, metric)) {
                                    currentCount++;
                                }
                            } else if (currentCount >= limit) {
                                break; 
                            }
                        }
                    }
                    if (currentCount >= limit) break;
                }
            }
            
            return Array.from(metricsSet).sort();
        }

        function calculateAnalytics(selectedPlayerId, metricsList) {
            console.log("Calculating analytics for player ID:", selectedPlayerId, "with metrics:", metricsList);
            const player = playerData.find(p => p.Player_ID == selectedPlayerId);
            if (!player) {
                console.warn("Player not found for analytics calculation:", selectedPlayerId);
                return {};
            }

            const position = player.Position;
            
            const minAge = parseInt(document.getElementById('min-age-filter').value) || 15;
            const maxAge = parseInt(document.getElementById('max-age-filter').value) || 45;
            const minMinutes = parseInt(document.getElementById('min-minutes-filter').value) || 0;

            let peerGroup = playerData.filter(p => 
                p.Player_ID != selectedPlayerId &&
                p.Season === player.Season &&
                (p.Age === 'N/A' || (p.Age >= minAge && p.Age <= maxAge)) &&
                p.Minutes_Played >= minMinutes
            );

            let initialPeerGroupSize = peerGroup.length;

            let filteredPeerGroup = peerGroup.filter(p => p.Position === player.Position);
            if (filteredPeerGroup.length < 5 && initialPeerGroupSize >= 5) {
                filteredPeerGroup = peerGroup.filter(p => p.Nationality === player.Nationality);
            }
            if (filteredPeerGroup.length < 5 && initialPeerGroupSize >= 5) {
                filteredPeerGroup = peerGroup.filter(p => p.Team === player.Team);
            }
            if (filteredPeerGroup.length < 5) {
                filteredPeerGroup = peerGroup;
            }
            peerGroup = filteredPeerGroup;
            console.log("Peer group size:", peerGroup.length);

            const results = {};

            metricsList.forEach(metric => {
                const playerValue = player[metric];
                const peerValues = peerGroup.map(p => p[metric]).filter(v => typeof v === 'number' && !isNaN(v));
                
                let average = 0;
                if (peerValues.length > 0) {
                    average = peerValues.reduce((a, b) => a + b, 0) / peerValues.length;
                }

                if (average === 0 && peerValues.every(val => val === 0)) {
                    // console.log(`Skipping metric ${metric} as all peer values are zero.`);
                    return;
                }

                let percentile = 0;
                if (peerValues.length > 0 && typeof playerValue === 'number' && !isNaN(playerValue)) {
                    const sortedPeers = [...peerValues].sort((a, b) => a - b);
                    const rank = sortedPeers.filter(v => v < playerValue).length;
                    percentile = (rank / sortedPeers.length) * 100;
                }
                
                if (LOWER_IS_BETTER_METRICS.includes(metric)) {
                    percentile = 100 - percentile;
                }

                results[metric] = {
                    playerValue: playerValue,
                    average: average,
                    percentile: percentile
                };
            });
            console.log("Analytics results:", results);
            return results;
        }

        function updateMetricsTable(analyticsData, playerName) {
            console.log("Updating metrics table for:", playerName, "with analytics data:", analyticsData);
            const categorizedMetricsContent = document.getElementById('categorized-metrics-table-container');
            categorizedMetricsContent.innerHTML = '';

            const strengths = [];
            const areasForDevelopment = [];
            const allCategorizedMetricsInTable = new Set();

            for (const metric in analyticsData) {
                const data = analyticsData[metric];
                if (typeof data.playerValue === 'number' && !isNaN(data.playerValue) && typeof data.average === 'number' && data.average !== 0) {
                    if (typeof data.percentile === 'number' && !isNaN(data.percentile)) {
                        if (data.percentile >= goodPerformanceThreshold) {
                            strengths.push({ metric, ...data });
                            allCategorizedMetricsInTable.add(metric);
                        } else if (data.percentile <= poorPerformanceThreshold) {
                            areasForDevelopment.push({ metric, ...data });
                            allCategorizedMetricsInTable.add(metric);
                        }
                    }
                }
            }

            strengths.sort((a, b) => b.percentile - a.percentile);
            areasForDevelopment.sort((a, b) => a.percentile - b.percentile);

            const generateCategoryHtml = (categoryName, metricsArray, isExpanded = false) => {
                const id = categoryName.toLowerCase().replace(/\s/g, '-') + '-metrics-table';
                const expandedClass = isExpanded ? 'expanded' : ''; 
                const arrowClass = isExpanded ? 'expanded' : '';

                let html = `
                    <div class="mb-4 bg-slate-50 rounded-lg shadow-sm overflow-hidden">
                        <div class="collapsible-header bg-slate-100 hover:bg-slate-200 p-4 font-semibold text-lg text-slate-800 flex justify-between items-center rounded-md ${expandedClass}" data-target="#${id}">
                            <span>${categoryName}</span>
                            <span class="arrow">▼</span>
                        </div>
                        <div id="${id}" class="collapsible-content p-4 ${expandedClass}">
                            <div class="overflow-x-auto">
                                <table class="min-w-full divide-y divide-slate-200">
                                    <thead class="bg-white">
                                        <tr>
                                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Metric</th>
                                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Player Value</th>
                                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Group Average</th>
                                            <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Percentile Rank</th>
                                        </tr>
                                    </thead>
                                    <tbody class="bg-white divide-y divide-slate-200">
                `;
                
                let hasMetrics = false;
                metricsArray.forEach(item => {
                    let rowClass = '';
                    if (item.percentile >= goodPerformanceThreshold) {
                        rowClass = 'bg-green-50';
                    } else if (item.percentile <= poorPerformanceThreshold) {
                        rowClass = 'bg-red-50';
                    }

                    html += `
                        <tr class="${rowClass}">
                            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">${item.metric.replace(/_/g, ' ')}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">${item.playerValue.toFixed(2)}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">${item.average.toFixed(2)}</td>
                            <td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">
                                <div class="flex items-center">
                                    <div class="w-20 bg-slate-200 rounded-full h-2.5">
                                        <div class="bg-sky-500 h-2.5 rounded-full" style="width: ${item.percentile.toFixed(0)}%"></div>
                                    </div>
                                    <span class="ml-3 font-medium">${item.percentile.toFixed(0)}%</span>
                                </div>
                            </td>
                        </tr>
                    `;
                    hasMetrics = true;
                });

                html += `
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        `;
        return hasMetrics ? html : '';
            };

            if (strengths.length > 0) {
                categorizedMetricsContent.insertAdjacentHTML('beforeend', generateCategoryHtml('Strengths', strengths, true));
            }

            if (areasForDevelopment.length > 0) {
                categorizedMetricsContent.insertAdjacentHTML('beforeend', generateCategoryHtml('Areas for Development', areasForDevelopment));
            }

            for (const categoryName in DETAILED_METRIC_CATEGORIES) {
                const metricsInThisCategory = DETAILED_METRIC_CATEGORIES[categoryName]
                    .filter(metric => {
                        const data = analyticsData[metric];
                        return !allCategorizedMetricsInTable.has(metric) && 
                               typeof data?.playerValue === 'number' && !isNaN(data.playerValue) &&
                               typeof data?.average === 'number' && data.average !== 0;
                    })
                    .map(metric => ({ metric, ...analyticsData[metric] }))
                    .sort((a, b) => a.metric.localeCompare(b.metric));

                if (metricsInThisCategory.length > 0) {
                    categorizedMetricsContent.insertAdjacentHTML('beforeend', generateCategoryHtml(categoryName.replace(/_/g, ' '), metricsInThisCategory));
                }
            }

            // Re-attach event listeners for newly added collapsible headers
            document.querySelectorAll('#categorized-metrics-table-container .collapsible-header').forEach(header => {
                header.removeEventListener('click', handleCollapsibleClick); // Remove old listeners to prevent duplicates
                header.addEventListener('click', handleCollapsibleClick);
            });

            // Helper to handle collapsible clicks for dynamically added elements
            function handleCollapsibleClick(event) {
                const header = event.currentTarget;
                const targetId = header.dataset.target;
                const targetContent = document.querySelector(targetId);
                const arrow = header.querySelector('.arrow');

                if (targetContent && arrow) {
                    const isExpanded = targetContent.classList.contains('expanded');
                    if (isExpanded) {
                        targetContent.style.maxHeight = null; // Collapse
                        targetContent.classList.remove('expanded');
                        arrow.classList.remove('expanded');
                    } else {
                        targetContent.style.maxHeight = targetContent.scrollHeight + "px";
                        targetContent.classList.add('expanded');
                        arrow.classList.add('expanded');
                        targetContent.addEventListener('transitionend', function handler() {
                            if (targetContent.classList.contains('expanded')) {
                                targetContent.style.maxHeight = 'none';
                            }
                            targetContent.removeEventListener('transitionend', handler);
                        });
                    }
                }
            }
            console.log("Metrics table updated.");
        }

        async function handleFileUpload(event) {
            console.log("handleFileUpload triggered.");
            const files = event.target.files;
            const fileStatus = document.getElementById('file-status');
            if (files.length === 0) {
                fileStatus.textContent = 'No file selected.';
                console.log("No file selected.");
                return;
            }
            fileStatus.textContent = `Processing ${files.length} file(s)...`;
            showLoading(true); // Show loading spinner

            let combinedRawData = [];
            let filesProcessedCount = 0;

            for (const file of files) {
                console.log(`Processing file: ${file.name}`);
                await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            console.log(`File ${file.name} loaded. Raw content length: ${e.target.result.length}`);
                            let parsedData;
                            if (file.name.endsWith('.csv')) {
                                parsedData = parseCsvManually(e.target.result);
                            } else if (file.name.endsWith('.xlsx')) {
                                const data = new Uint8Array(e.target.result);
                                const workbook = XLSX.read(data, {type: 'array'});
                                const firstSheetName = workbook.SheetNames[0];
                                const worksheet = workbook.Sheets[firstSheetName];
                                parsedData = XLSX.utils.sheet_to_json(worksheet);
                                console.log(`Parsed XLSX data for ${file.name} (first 5 rows):`, parsedData.slice(0, 5));
                            } else {
                                throw new Error(`Unsupported file type for ${file.name}.`);
                            }
                            combinedRawData = combinedRawData.concat(parsedData);
                            filesProcessedCount++;
                            fileStatus.textContent = `Processed ${filesProcessedCount}/${files.length} files.`;
                            resolve();
                        } catch (error) {
                            console.error(`Error processing file ${file.name}:`, error);
                            fileStatus.textContent = `Error processing ${file.name}: ${error.message}`;
                            reject(error);
                        }
                    };

                    reader.onerror = function() {
                        console.error(`FileReader error for ${file.name}:`, reader.error);
                        fileStatus.textContent = `Error reading file ${file.name}: ${reader.error}`;
                        reject(reader.error);
                    };

                    if (file.name.endsWith('.xlsx')) {
                        reader.readAsArrayBuffer(file);
                    } else {
                        reader.readAsText(file);
                    }
                }).catch(() => { /* Suppress individual file errors to continue processing others */ });
            }

            if (combinedRawData.length > 0) {
                playerData.length = 0; // Clear existing data
                playerData.push(...cleanAndPreprocessData(combinedRawData)); // Populate global playerData
                console.log("Global playerData after preprocessing:", playerData.length, "records.");

                // Populate allAvailableMetrics
                allAvailableMetrics.length = 0; // Clear existing array
                const allHeaders = new Set();
                playerData.forEach(row => Object.keys(row).forEach(key => allHeaders.add(key)));
                allHeaders.forEach(header => {
                    const hasMeaningfulNumericData = playerData.some(row => 
                        typeof row[header] === 'number' && !isNaN(row[header]) && row[header] !== 0
                    );
                    if (hasMeaningfulNumericData) {
                        allAvailableMetrics.push(header);
                    }
                });
                allAvailableMetrics.sort((a, b) => {
                    const aIsPer90 = a.endsWith('_Per_90');
                    const bIsPer90 = b.endsWith('_Per_90');
                    if (aIsPer90 && !bIsPer90) return -1;
                    if (!aIsPer90 && bIsPer90) return 1;
                    return a.localeCompare(b);
                });

                populatePlayerSelect(playerData);
                populateComparisonSelects(playerData);
                populateMetricSelectionUI(selectedChartType); // Populate initial metric selection UI

                fileStatus.textContent = `All ${files.length} files loaded and processed. Select a player.`;
                document.getElementById('dashboard-content').classList.remove('hidden');
                document.getElementById('initial-message').classList.add('hidden');
                
                if (playerData.length > 0) {
                    document.getElementById('player-select').value = playerData[0].Player_Name;
                    handlePlayerSelection({ target: { value: playerData[0].Player_Name } }); // Trigger selection programmatically
                } else {
                    fileStatus.textContent = `No valid player data found after processing all files. Please check file formats or ensure they are not empty.`;
                    document.getElementById('dashboard-content').classList.add('hidden');
                    document.getElementById('initial-message').classList.remove('hidden');
                }

                let overallMinAge = Infinity;
                let overallMaxAge = -Infinity;
                let overallMinMinutes = Infinity;
                let overallMaxMinutes = -Infinity;

                playerData.forEach(player => {
                    if (typeof player.Age === 'number' && !isNaN(player.Age)) {
                        overallMinAge = Math.min(overallMinAge, player.Age);
                        overallMaxAge = Math.max(overallMaxAge, player.Age);
                    }
                    if (typeof player.Minutes_Played === 'number' && !isNaN(player.Minutes_Played)) {
                        overallMinMinutes = Math.min(overallMinMinutes, player.Minutes_Played);
                        overallMaxMinutes = Math.max(overallMaxMinutes, player.Minutes_Played);
                    }
                });

                const minAgeFilter = document.getElementById('min-age-filter');
                const maxAgeFilter = document.getElementById('max-age-filter');
                const minMinutesFilter = document.getElementById('min-minutes-filter');

                if (overallMinAge !== Infinity) {
                    minAgeFilter.min = Math.floor(overallMinAge);
                    minAgeFilter.max = Math.ceil(overallMaxAge);
                    minAgeFilter.value = Math.floor(overallMinAge);
                } else {
                    minAgeFilter.min = 15;
                    minAgeFilter.max = 45;
                    minAgeFilter.value = 15;
                }
                if (overallMaxAge !== -Infinity) {
                    maxAgeFilter.min = Math.floor(overallMinAge);
                    maxAgeFilter.max = Math.ceil(overallMaxAge);
                    maxAgeFilter.value = Math.ceil(overallMaxAge);
                } else {
                    maxAgeFilter.min = 15;
                    maxAgeFilter.max = 45;
                    maxAgeFilter.value = 45;
                }
                if (overallMinMinutes !== Infinity) {
                    minMinutesFilter.min = 0;
                    minMinutesFilter.max = Math.ceil(overallMaxMinutes);
                    minMinutesFilter.value = 0;
                } else {
                    minMinutesFilter.min = 0;
                    minMinutesFilter.max = 10000;
                    minMinutesFilter.value = 0;
                }

            } else {
                fileStatus.textContent = `No valid data found in any of the uploaded files.`;
                document.getElementById('dashboard-content').classList.add('hidden');
                document.getElementById('initial-message').classList.remove('hidden');
            }
            showLoading(false); // Hide loading spinner
            console.log("handleFileUpload completed.");
        }

        function handlePlayerSelection(event) {
            const selectedPlayerName = event.target.value;
            console.log("Player selected:", selectedPlayerName);
            if (selectedPlayerName) {
                // Reset configured metric selections when a new player is selected
                configuredRadarMetrics = new Set();
                configuredBarMetrics = new Set();
                configuredHorizontalBarMetric = '';
                configuredDoughnutMetric = '';
                configuredBubbleXMetric = '';
                configuredBubbleYMetric = '';
                configuredBubbleSizeMetric = '';
                configuredPolarAreaMetrics = new Set();
                configuredLineMetric = '';
                
                // Re-populate the metric selection UI based on the current chart type and new player
                populateMetricSelectionUI(selectedChartType);
                updateDashboard(selectedPlayerName);
            }
        }

        // Function to create or update Radar Chart
        function createRadarChart(ctx, analyticsData, playerName) {
            const labels = Object.keys(analyticsData);
            const data = labels.map(label => analyticsData[label].percentile);

            if (labels.length === 0) {
                return null;
            }

            return new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${playerName} Percentile Rank`,
                        data: data,
                        backgroundColor: 'rgba(56, 189, 248, 0.2)', // sky-400 with opacity
                        borderColor: 'rgba(14, 165, 233, 1)', // sky-600
                        pointBackgroundColor: 'rgba(14, 165, 233, 1)',
                        pointBorderColor: '#fff',
                        pointHoverBackgroundColor: '#fff',
                        pointHoverBorderColor: 'rgba(14, 165, 233, 1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                stepSize: 25,
                                backdropColor: 'transparent', // Make tick labels transparent background
                                color: '#64748b' // slate-500
                            },
                            grid: {
                                color: '#e2e8f0' // slate-200
                            },
                            angleLines: {
                                color: '#e2e8f0' // slate-200
                            },
                            pointLabels: {
                                font: {
                                    size: 12
                                },
                                color: '#334155' // slate-700
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#334155' // slate-700
                            }
                        },
                        tooltip: {
                            enabled: false, // Disable default tooltip
                            external: externalTooltipHandler // Use custom tooltip handler
                        }
                    }
                }
            });
        }

        // Function to create or update Bar Chart
        function createBarChart(ctx, analyticsData, playerName) {
            const labels = Object.keys(analyticsData);
            const playerValues = labels.map(label => analyticsData[label].playerValue);
            const averageValues = labels.map(label => analyticsData[label].average);

            if (labels.length === 0) {
                return null;
            }

            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: playerName,
                            data: playerValues,
                            backgroundColor: 'rgba(56, 189, 248, 0.8)', // sky-400 with opacity
                            borderColor: 'rgba(14, 165, 233, 1)', // sky-600
                            borderWidth: 1
                        },
                        {
                            label: 'Group Average',
                            data: averageValues,
                            backgroundColor: 'rgba(203, 213, 225, 0.8)', // slate-300 with opacity
                            borderColor: 'rgba(100, 116, 139, 1)', // slate-500
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: '#e2e8f0' // slate-200
                            },
                            ticks: { color: '#64748b' } // slate-500
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: { color: '#64748b' } // slate-500
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: '#334155' // slate-700
                            }
                        },
                        tooltip: {
                            enabled: false, // Disable default tooltip
                            external: externalTooltipHandler // Use custom tooltip handler
                        }
                    }
                }
            });
        }

        // Function to create or update Horizontal Bar Chart
        function createHorizontalBarChart(ctx, selectedPlayerId, metric) {
            const selectedPlayer = playerData.find(p => p.Player_ID === selectedPlayerId);
            if (!selectedPlayer || !metric) {
                return null;
            }

            const analytics = calculateAnalytics(selectedPlayer.Player_ID, [metric]);
            const playerValue = analytics[metric]?.playerValue;
            const averageValue = analytics[metric]?.average;

            if (typeof playerValue !== 'number' || isNaN(playerValue) || typeof averageValue !== 'number' || isNaN(averageValue) || averageValue === 0) {
                return null;
            }

            return new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [metric.replace(/_/g, ' ')],
                    datasets: [
                        {
                            label: selectedPlayer.Player_Name,
                            data: [playerValue],
                            backgroundColor: 'rgba(56, 189, 248, 0.8)', // sky-400
                            borderColor: 'rgba(14, 165, 233, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Group Average',
                            data: [averageValue],
                            backgroundColor: 'rgba(203, 213, 225, 0.8)', // slate-300
                            borderColor: 'rgba(100, 116, 139, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    indexAxis: 'y', // Make it horizontal
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            grid: { color: '#e2e8f0' },
                            ticks: { color: '#64748b' }
                        },
                        y: {
                            grid: { display: false },
                            ticks: { color: '#64748b' }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { color: '#334155' } },
                        tooltip: { enabled: false, external: externalTooltipHandler }
                    }
                }
            });
        }

        // Function to create or update Doughnut Chart
        function createDoughnutChart(ctx, selectedPlayerId, metric) {
            const selectedPlayer = playerData.find(p => p.Player_ID === selectedPlayerId);
            if (!selectedPlayer || !metric) {
                return null;
            }

            const analytics = calculateAnalytics(selectedPlayer.Player_ID, [metric]);
            const percentile = analytics[metric]?.percentile;

            if (typeof percentile !== 'number' || isNaN(percentile)) {
                return null;
            }

            return new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [`${metric.replace(/_/g, ' ')} Percentile`, 'Remaining'],
                    datasets: [{
                        data: [percentile, 100 - percentile],
                        backgroundColor: ['rgba(56, 189, 248, 0.8)', 'rgba(203, 213, 225, 0.8)'], // sky-400, slate-300
                        borderColor: ['rgba(14, 165, 233, 1)', 'rgba(100, 116, 139, 1)'],
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: '70%', // Make it a ring chart
                    plugins: {
                        legend: { position: 'top', labels: { color: '#334155' } },
                        tooltip: { enabled: false, external: externalTooltipHandler }
                    }
                }
            });
        }

        // Function to create or update Bubble Chart
        function createBubbleChart(ctx, selectedPlayerId, metricX, metricY, metricSize) {
            const selectedPlayer = playerData.find(p => p.Player_ID === selectedPlayerId);
            if (!selectedPlayer || !metricX || !metricY || !metricSize) {
                return null;
            }

            const bubbleData = playerData.filter(p =>
                typeof p[metricX] === 'number' && !isNaN(p[metricX]) && p[metricX] !== 0 &&
                typeof p[metricY] === 'number' && !isNaN(p[metricY]) && p[metricY] !== 0 &&
                typeof p[metricSize] === 'number' && !isNaN(p[metricSize]) && p[metricSize] !== 0
            ).map(p => ({
                x: p[metricX],
                y: p[metricY],
                r: Math.max(5, p[metricSize] / 5), // Scale size for visibility, ensure min size
                name: p.Player_Name,
                isCurrentPlayer: p.Player_ID === selectedPlayerId
            }));

            if (bubbleData.length === 0) {
                return null;
            }

            const currentPlayerPoint = bubbleData.find(d => d.isCurrentPlayer);
            const otherPlayersPoints = bubbleData.filter(d => !d.isCurrentPlayer);

            const datasets = [
                {
                    label: 'Other Players',
                    data: otherPlayersPoints,
                    backgroundColor: 'rgba(100, 116, 139, 0.6)', // slate-500
                    borderColor: 'rgba(100, 116, 139, 1)',
                    parsing: {
                        xAxisKey: 'x',
                        yAxisKey: 'y',
                        rAxisKey: 'r'
                    }
                }
            ];

            if (currentPlayerPoint) {
                datasets.push({
                    label: selectedPlayer.Player_Name,
                    data: [currentPlayerPoint],
                    backgroundColor: 'rgba(14, 165, 233, 0.8)', // sky-600
                    borderColor: 'rgba(14, 165, 233, 1)',
                    parsing: {
                        xAxisKey: 'x',
                        yAxisKey: 'y',
                        rAxisKey: 'r'
                    }
                });
            }

            return new Chart(ctx, {
                type: 'bubble',
                data: { datasets: datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: metricX.replace(/_/g, ' '), color: '#64748b' },
                            grid: { color: '#e2e8f0' },
                            ticks: { color: '#64748b' }
                        },
                        y: {
                            title: { display: true, text: metricY.replace(/_/g, ' '), color: '#64748b' },
                            grid: { color: '#e2e8f0' },
                            ticks: { color: '#64748b' }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { color: '#334155' } },
                        tooltip: { enabled: false, external: externalTooltipHandler }
                    }
                }
            });
        }

        // Function to create or update Polar Area Chart
        function createPolarAreaChart(ctx, analyticsData, playerName) {
            const labels = Object.keys(analyticsData);
            const data = labels.map(label => analyticsData[label].playerValue);

            if (labels.length === 0) {
                return null;
            }

            const backgroundColors = labels.map((_, i) => `hsl(${i * (360 / labels.length)}, 70%, 70%)`);
            const borderColors = labels.map((_, i) => `hsl(${i * (360 / labels.length)}, 70%, 50%)`);

            return new Chart(ctx, {
                type: 'polarArea',
                data: {
                    labels: labels,
                    datasets: [{
                        label: playerName,
                        data: data,
                        backgroundColor: backgroundColors,
                        borderColor: borderColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            beginAtZero: true,
                            ticks: { backdropColor: 'transparent', color: '#64748b' },
                            grid: { color: '#e2e8f0' }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { color: '#334155' } },
                        tooltip: { enabled: false, external: externalTooltipHandler }
                    }
                }
            });
        }

        // Function to create or update Line Chart
        function createLineChart(ctx, selectedPlayerId, metric) {
            if (!metric) {
                return null;
            }

            const dataPoints = playerData.filter(p => typeof p[metric] === 'number' && !isNaN(p[metric]) && p[metric] !== 0)
                                         .map(p => ({ x: p.Player_Name, y: p[metric], isCurrentPlayer: p.Player_ID === selectedPlayerId }));

            if (dataPoints.length === 0) {
                return null;
            }

            // Sort data points by metric value for better visualization of distribution
            dataPoints.sort((a, b) => a.y - b.y);

            const labels = dataPoints.map(p => p.x);
            const data = dataPoints.map(p => p.y);
            const pointBackgroundColors = dataPoints.map(p => p.isCurrentPlayer ? 'rgba(14, 165, 233, 1)' : 'rgba(100, 116, 139, 0.6)');
            const pointBorderColors = dataPoints.map(p => p.isCurrentPlayer ? '#fff' : 'rgba(100, 116, 139, 1)');
            const pointRadii = dataPoints.map(p => p.isCurrentPlayer ? 6 : 3);


            return new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `${metric.replace(/_/g, ' ')} Values`,
                        data: data,
                        fill: false,
                        borderColor: 'rgba(56, 189, 248, 0.8)', // sky-400
                        tension: 0.1,
                        pointBackgroundColor: pointBackgroundColors,
                        pointBorderColor: pointBorderColors,
                        pointRadius: pointRadii,
                        pointHoverRadius: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: { display: true, text: 'Players', color: '#64748b' },
                            grid: { display: false },
                            ticks: { color: '#64748b', autoSkip: true, maxRotation: 90, minRotation: 45 } // Rotate labels for readability
                        },
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: metric.replace(/_/g, ' '), color: '#64748b' },
                            grid: { color: '#e2e8f0' },
                            ticks: { color: '#64748b' }
                        }
                    },
                    plugins: {
                        legend: { position: 'top', labels: { color: '#334155' } },
                        tooltip: { enabled: false, external: externalTooltipHandler }
                    }
                }
            });
        }

        function handlePlayerComparison() {
            const playerNames = [];
            const select1 = document.getElementById('compare-player-1');
            const select2 = document.getElementById('compare-player-2');
            const select3 = document.getElementById('compare-player-3');
            const comparisonMessage = document.getElementById('comparison-message');

            if (select1 && select1.value) playerNames.push(select1.value);
            if (select2 && select2.value) playerNames.push(select2.value);
            if (select3 && select3.value) playerNames.push(select3.value);

            console.log("Players selected for comparison:", playerNames);

            const comparisonTableContainer = document.getElementById('comparison-table-container');
            const comparisonTable = document.getElementById('comparison-table');
            comparisonTable.innerHTML = ''; // Clear previous table content
            comparisonMessage.classList.add('hidden'); // Hide previous message

            if (playerNames.length < 2) {
                comparisonTableContainer.classList.add('hidden');
                comparisonMessage.textContent = 'Please select at least two players for comparison.';
                comparisonMessage.classList.remove('hidden');
                return;
            }

            // Ensure the comparison table container is visible
            comparisonTableContainer.classList.remove('hidden');

            // Get the latest season data for selected players
            const selectedPlayersData = playerNames.map(name => 
                playerData.filter(p => p.Player_Name === name)
                          .sort((a, b) => (typeof b.Season === 'number' ? b.Season : -Infinity) - (typeof a.Season === 'number' ? a.Season : -Infinity))
                          [0]
            ).filter(p => p); // Filter out any undefined players if not found

            console.log("Selected players data for comparison:", selectedPlayersData);

            if (selectedPlayersData.length < 2) {
                comparisonTableContainer.classList.add('hidden');
                comparisonMessage.textContent = 'Could not find data for all selected players or not enough players with valid data for comparison. Please ensure they are in the uploaded file and have valid data.';
                comparisonMessage.classList.remove('hidden');
                return;
            }

            // Determine ALL common numeric metrics across selected players
            let allCommonNumericMetrics = new Set();
            if (selectedPlayersData.length > 0) {
                Object.keys(selectedPlayersData[0]).forEach(key => {
                    const isCommonAndNumeric = selectedPlayersData.every(player => 
                        typeof player[key] === 'number' && !isNaN(player[key])
                    );
                    if (isCommonAndNumeric) {
                        allCommonNumericMetrics.add(key);
                    }
                });
            }
            allCommonNumericMetrics = Array.from(allCommonNumericMetrics).sort();
            console.log("All common numeric metrics:", allCommonNumericMetrics);


            // Categorize these common metrics for display
            const categorizedComparisonMetrics = {
                'Physical': [],
                'Technical': [],
                'Tactical': [],
                'Mental_Discipline': [],
                'General': [] // For metrics that don't fit specific categories
            };

            allCommonNumericMetrics.forEach(metric => {
                let assignedToCategory = false;
                for (const categoryName in DETAILED_METRIC_CATEGORIES) {
                    if (DETAILED_METRIC_CATEGORIES[categoryName].includes(metric)) {
                        categorizedComparisonMetrics[categoryName].push(metric);
                        assignedToCategory = true;
                        break;
                    }
                }
                if (!assignedToCategory) {
                    categorizedComparisonMetrics['General'].push(metric);
                }
            });

            // Sort metrics within each category alphabetically
            for (const category in categorizedComparisonMetrics) {
                categorizedComparisonMetrics[category].sort();
            }

            console.log("Categorized common metrics for comparison (for display):", categorizedComparisonMetrics);

            // Create table header
            let headerHtml = `
                <thead>
                    <tr class="bg-white">
                        <th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">Metric</th>
            `;
            selectedPlayersData.forEach(player => {
                headerHtml += `<th scope="col" class="px-6 py-3 text-left text-xs font-medium text-slate-500 uppercase tracking-wider">${player.Player_Name} (${player.Team})</th>`;
            });
            headerHtml += `</tr></thead>`;
            
            let tableBodyHtml = `<tbody class="bg-white divide-y divide-slate-200">`;

            let hasAnyMetricsToDisplay = false;

            // Create table rows for each categorized common metric
            for (const categoryName in categorizedComparisonMetrics) {
                const metricsInThisCategory = categorizedComparisonMetrics[categoryName];
                if (metricsInThisCategory.length > 0) {
                    hasAnyMetricsToDisplay = true;
                    tableBodyHtml += `
                        <tr class="bg-slate-100">
                            <td colspan="${selectedPlayersData.length + 1}" class="px-6 py-3 text-left text-sm font-semibold text-slate-800">${categoryName.replace(/_/g, ' ')} Metrics</td>
                        </tr>
                    `;
                    metricsInThisCategory.forEach(metric => {
                        tableBodyHtml += `<tr><td class="px-6 py-4 whitespace-nowrap text-sm font-medium text-slate-900">${metric.replace(/_/g, ' ')}</td>`;
                        selectedPlayersData.forEach(player => {
                            const value = player[metric];
                            tableBodyHtml += `<td class="px-6 py-4 whitespace-nowrap text-sm text-slate-500">${typeof value === 'number' && !isNaN(value) ? value.toFixed(2) : '-'}</td>`;
                        });
                        tableBodyHtml += `</tr>`;
                    });
                }
            }
            tableBodyHtml += `</tbody>`;

            if (!hasAnyMetricsToDisplay) {
                comparisonMessage.textContent = 'No common numeric metrics found for the selected players to compare across the specified categories.';
                comparisonMessage.classList.remove('hidden');
                comparisonTableContainer.classList.add('hidden'); // Ensure container is hidden if no metrics
                return;
            }

            comparisonTable.innerHTML = headerHtml + tableBodyHtml;
        }

        async function generateScoutingReport() {
            const selectedPlayerName = document.getElementById('player-select').value;
            // Find the latest season's data for the selected player for profile and current stats
            const selectedPlayer = playerData
                .filter(p => p.Player_Name === selectedPlayerName)
                .sort((a, b) => (typeof b.Season === 'number' ? b.Season : -Infinity) - (typeof a.Season === 'number' ? a.Season : -Infinity))
                [0]; // Get the most recent season's data

            if (!selectedPlayer) {
                document.getElementById('insight-text').textContent = 'Please select a player first.';
                document.getElementById('insight-output').classList.remove('hidden');
                return;
            }

            const insightOutputDiv = document.getElementById('insight-output');
            const insightTextP = document.getElementById('insight-text');
            const insightLoadingP = document.getElementById('insight-loading');
            const generateInsightBtn = document.getElementById('generate-insight-btn');

            insightOutputDiv.classList.remove('hidden');
            insightTextP.textContent = '';
            insightLoadingP.classList.remove('hidden');
            generateInsightBtn.disabled = true;

            const playerProfile = `Player Name: ${selectedPlayer.Player_Name}\nPosition: ${selectedPlayer.Position}\nTeam: ${selectedPlayer.Team}\nNationality: ${selectedPlayer.Nationality}\nAge: ${selectedPlayer.Age}`;
            
            let metricsSummary = 'Key Metrics:\n';
            let strengthsSummary = 'Strengths (Top Performers):\n';
            let weaknessesSummary = 'Areas for Development (Bottom Performers):\n';
            let hasStrengths = false;
            let hasWeaknesses = false;

            // Iterate through currentAnalytics to build the prompt
            for (const metric in currentAnalytics) {
                const data = currentAnalytics[metric];
                // Only include metrics in the LLM prompt if they have a valid numeric player value AND non-zero group average
                if (typeof data.playerValue === 'number' && !isNaN(data.playerValue) && typeof data.average === 'number' && data.average !== 0) {
                    metricsSummary += `- ${metric.replace(/_/g, ' ')}: Player Value: ${data.playerValue.toFixed(2)}, Group Average: ${data.average.toFixed(2)}, Percentile: ${data.percentile.toFixed(0)}%\n`;
                    
                    if (data.percentile >= goodPerformanceThreshold) {
                        strengthsSummary += `  - ${metric.replace(/_/g, ' ')} (${data.percentile.toFixed(0)}% percentile)\n`;
                        hasStrengths = true;
                    } else if (data.percentile <= poorPerformanceThreshold) {
                        weaknessesSummary += `  - ${metric.replace(/_/g, ' ')} (${data.percentile.toFixed(0)}% percentile)\n`;
                        hasWeaknesses = true;
                    }
                }
            }
            
            if (!hasStrengths) strengthsSummary += '  (No outstanding strengths identified based on current thresholds)\n';
            if (!hasWeaknesses) weaknessesSummary += '  (No significant areas for development identified based on current thresholds)\n';


            const prompt = `Generate a concise scouting report for the following player based on the provided data. Highlight their strengths and weaknesses relative to their peer group (same position, team, and nationality). Focus on the most impactful metrics.
            
${playerProfile}

${metricsSummary}

${strengthsSummary}

${weaknessesSummary}

Scouting Report:`;

            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            // IMPORTANT: For local machine execution, you need to replace "" with your actual Gemini API Key.
            // Get your API key from Google AI Studio: https://aistudio.google.com/app/apikey
            const apiKey = "AIzaSyAFBW-1l8nWjOwXZHVj9_BNIIIv9hAYMwQ"; // Replace with your actual API Key
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    const text = result.candidates[0].content.parts[0].text;
                    insightTextP.textContent = text;
                } else {
                    insightTextP.textContent = 'Failed to generate insight. No valid response from AI.';
                    console.error('AI response structure unexpected:', result);
                }
            } catch (error) {
                insightTextP.textContent = `Error generating insight: ${error.message}`;
                console.error('Fetch error:', error);
            } finally {
                insightLoadingP.classList.add('hidden');
                generateInsightBtn.disabled = false;
            }
        }

        function exportChartAsPng(event) {
            const chartId = event.target.dataset.chartId;
            const canvas = document.getElementById(chartId);
            if (canvas) {
                const link = document.createElement('a');
                link.download = `${chartId}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
            } else {
                console.error(`Canvas with ID ${chartId} not found.`);
            }
        }

        function exportDetailedMetricsToCsv() {
            const selectedPlayerName = document.getElementById('player-select').value;
            const player = playerData.find(p => p.Player_Name === selectedPlayerName);
            if (!player) {
                // Using a custom message box instead of alert
                const messageBox = document.createElement('div');
                messageBox.classList.add('fixed', 'top-1/2', 'left-1/2', '-translate-x-1/2', '-translate-y-1/2', 'bg-red-500', 'text-white', 'p-4', 'rounded-lg', 'shadow-lg', 'z-[10000]');
                messageBox.textContent = 'Please select a player first to export data.';
                document.body.appendChild(messageBox);
                setTimeout(() => messageBox.remove(), 3000); // Remove after 3 seconds
                return;
            }

            let csvContent = "Metric,Player Value,Group Average,Percentile Rank\n";
            
            // Collect all metrics that are displayed in the table
            const metricsToExport = [];
            for (const metric in currentAnalytics) {
                const data = currentAnalytics[metric];
                if (typeof data.playerValue === 'number' && !isNaN(data.playerValue) && typeof data.average === 'number' && data.average !== 0) {
                    metricsToExport.push({ metric, ...data });
                }
            }
            metricsToExport.sort((a,b) => a.metric.localeCompare(b.metric)); // Sort alphabetically for consistent output

            metricsToExport.forEach(item => {
                const row = [
                    `"${item.metric.replace(/_/g, ' ')}"`, // Quote metric name to handle spaces
                    item.playerValue.toFixed(2),
                    item.average.toFixed(2),
                    item.percentile.toFixed(0) + '%'
                ].join(',');
                csvContent += row + "\n";
            });

            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            if (link.download !== undefined) { // Feature detection for HTML5 download attribute
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', `${selectedPlayerName}_detailed_metrics.csv`);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } else {
                // Fallback for browsers that don't support download attribute
                const messageBox = document.createElement('div');
                messageBox.classList.add('fixed', 'top-1/2', 'left-1/2', '-translate-x-1/2', '-translate-y-1/2', 'bg-red-500', 'text-white', 'p-4', 'rounded-lg', 'shadow-lg', 'z-[10000]');
                messageBox.textContent = 'Your browser does not support direct CSV file downloads. Please use "Save As..." from your browser\'s menu.';
                document.body.appendChild(messageBox);
                setTimeout(() => messageBox.remove(), 5000);
            }
        }

        async function downloadPdfReport() {
            const mainContent = document.getElementById('dashboard-main-content');
            if (!mainContent) {
                const messageBox = document.createElement('div');
                messageBox.classList.add('fixed', 'top-1/2', 'left-1/2', '-translate-x-1/2', '-translate-y-1/2', 'bg-red-500', 'text-white', 'p-4', 'rounded-lg', 'shadow-lg', 'z-[10000]');
                messageBox.textContent = 'Dashboard content not found for PDF export.';
                document.body.appendChild(messageBox);
                setTimeout(() => messageBox.remove(), 3000);
                return;
            }

            // Temporarily expand all collapsible sections for PDF export
            const collapsibleContents = document.querySelectorAll('.collapsible-content:not(.expanded)');
            collapsibleContents.forEach(content => {
                content.classList.add('expanded');
                content.style.maxHeight = content.scrollHeight + "px";
                const header = content.previousElementSibling;
                if (header && header.classList.contains('collapsible-header')) {
                    const arrow = header.querySelector('span:last-child');
                    if (arrow) {
                        arrow.classList.remove('rotate-0');
                        arrow.classList.add('rotate-180');
                    }
                }
            });

            // Update all active charts to ensure they are rendered correctly before capture
            for (const chartId in activeCharts) {
                if (activeCharts[chartId]) {
                    activeCharts[chartId].update();
                }
            }

            // Small delay to ensure all elements are rendered and expanded
            await new Promise(resolve => setTimeout(resolve, 500)); 

            const pdf = new window.jspdf.jsPDF('p', 'pt', 'a4'); // 'p' for portrait, 'pt' for points, 'a4' for size
            const margin = 20;
            let yOffset = margin;

            // Function to add content to PDF, handling page breaks
            const addContentToPdf = async (element) => {
                const canvas = await html2canvas(element, { scale: 2 }); // Scale for better resolution
                const imgData = canvas.toDataURL('image/png');
                const imgWidth = pdf.internal.pageSize.getWidth() - 2 * margin;
                const imgHeight = (canvas.height * imgWidth) / canvas.width;

                if (yOffset + imgHeight > pdf.internal.pageSize.getHeight() - margin) {
                    pdf.addPage();
                    yOffset = margin;
                }
                pdf.addImage(imgData, 'PNG', margin, yOffset, imgWidth, imgHeight);
                yOffset += imgHeight + 10; // Add some padding
            };

            // Capture each section individually for better control over page breaks
            const sectionsToCapture = [
                document.getElementById('intro-how-to'),
                document.getElementById('controls'),
                document.getElementById('player-profile-section'),
                document.getElementById('customize-charts-section'),
                document.getElementById('selected-visualizations-section'), // Capture the entire visualizations section
                document.getElementById('player-comparison-section'),
                document.getElementById('detailed-metrics-section'),
                document.getElementById('ai-insight-section'),
                document.getElementById('report-export-section') // Include the export section itself
            ].filter(Boolean); // Filter out any null elements

            for (const section of sectionsToCapture) {
                await addContentToPdf(section);
            }
            
            pdf.save('Sports_Scout_Report.pdf');

            // Revert collapsible sections to their original state after PDF generation
            collapsibleContents.forEach(content => {
                content.style.maxHeight = null;
                content.classList.remove('expanded'); // Remove expanded class
                const header = content.previousElementSibling;
                if (header && header.classList.contains('collapsible-header')) {
                    const arrow = header.querySelector('span:last-child');
                    if (arrow) {
                        arrow.classList.remove('rotate-180');
                        arrow.classList.add('rotate-0');
                    }
                }
            });
        }

        // Function to initialize the dashboard (event listeners, initial UI state)
        function initApp() {
            // Event Listeners
            document.getElementById('file-upload').addEventListener('change', async (event) => {
                showLoading(true);
                await handleFileUpload(event);
                showLoading(false);
            });
            document.getElementById('player-select').addEventListener('change', handlePlayerSelection);
            document.getElementById('apply-filters-btn').addEventListener('click', () => {
                const selectedPlayerName = document.getElementById('player-select').value;
                if (selectedPlayerName) {
                    updateDashboard(selectedPlayerName);
                }
            });

            document.getElementById('chart-type-select').addEventListener('change', (event) => {
                selectedChartType = event.target.value;
                populateMetricSelectionUI(selectedChartType);
            });

            document.getElementById('add-chart-to-dashboard-btn').addEventListener('click', addChartToDashboard);

            document.getElementById('reset-metrics-btn').addEventListener('click', () => {
                // Reset only the currently configured metric selections for the active chart type
                switch (selectedChartType) {
                    case 'radar': configuredRadarMetrics = new Set(); break;
                    case 'bar': configuredBarMetrics = new Set(); break;
                    case 'horizontalBar': configuredHorizontalBarMetric = ''; break;
                    case 'doughnut': configuredDoughnutMetric = ''; break;
                    case 'bubble': configuredBubbleXMetric = ''; configuredBubbleYMetric = ''; configuredBubbleSizeMetric = ''; break;
                    case 'polarArea': configuredPolarAreaMetrics = new Set(); break;
                    case 'line': configuredLineMetric = ''; break;
                }
                populateMetricSelectionUI(selectedChartType); // Re-populate the UI with default/empty selections
            });

            document.getElementById('apply-formatting-btn').addEventListener('click', () => {
                goodPerformanceThreshold = parseInt(document.getElementById('good-threshold').value) || 75;
                poorPerformanceThreshold = parseInt(document.getElementById('poor-threshold').value) || 25;
                const selectedPlayerName = document.getElementById('player-select').value;
                if (selectedPlayerName) {
                    const selectedPlayer = playerData.find(p => p.Player_Name === selectedPlayerName);
                    if (selectedPlayer) {
                        const allRelevantMetricsForAnalytics = new Set();
                        for (const category in DETAILED_METRIC_CATEGORIES) {
                            DETAILED_METRIC_CATEGORIES[category].forEach(metric => {
                                if (typeof selectedPlayer[metric] === 'number' && !isNaN(selectedPlayer[metric])) {
                                    allRelevantMetricsForAnalytics.add(metric);
                                }
                            });
                        }
                        currentAnalytics = calculateAnalytics(selectedPlayer.Player_ID, Array.from(allRelevantMetricsForAnalytics));
                        updateMetricsTable(currentAnalytics, selectedPlayer.Player_Name);
                    }
                }
            });

            // Event listeners for collapsible sections
            document.querySelectorAll('.collapsible-header').forEach(header => {
                header.addEventListener('click', () => toggleCollapsible(header));
            });

            // Player Comparison
            document.getElementById('compare-players-btn').addEventListener('click', handlePlayerComparison);

            // Report Generation and Export
            document.getElementById('generate-insight-btn').addEventListener('click', generateScoutingReport);
            document.getElementById('export-detailed-csv-btn').addEventListener('click', exportDetailedMetricsToCsv);
            document.getElementById('download-pdf-btn').addEventListener('click', downloadPdfReport);
            // Chart export buttons are now dynamically attached when charts are added

            // Initial UI State setup
            document.getElementById('file-status').textContent = 'Awaiting file upload...';
            document.getElementById('dashboard-content').classList.add('hidden');
            document.getElementById('initial-message').classList.remove('hidden');

            // Expand "How to Use" and "Detailed Metrics" by default
            const howToUseHeader = document.querySelector('#intro-how-to .collapsible-header');
            if (howToUseHeader) {
                toggleCollapsible(howToUseHeader);
            }
            const detailedMetricsHeader = document.querySelector('#detailed-metrics-section .collapsible-header');
            if (detailedMetricsHeader) {
                toggleCollapsible(detailedMetricsHeader);
            }
        }

        // Call initApp when the DOM is fully loaded
        window.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
